{
  "version": 3,
  "sources": ["../../tslib/tslib.es6.mjs", "../../rxjs/src/internal/util/isFunction.ts", "../../rxjs/src/internal/util/createErrorClass.ts", "../../rxjs/src/internal/util/UnsubscriptionError.ts", "../../rxjs/src/internal/util/arrRemove.ts", "../../rxjs/src/internal/Subscription.ts", "../../rxjs/src/internal/config.ts", "../../rxjs/src/internal/scheduler/timeoutProvider.ts", "../../rxjs/src/internal/util/reportUnhandledError.ts", "../../rxjs/src/internal/util/noop.ts", "../../rxjs/src/internal/NotificationFactories.ts", "../../rxjs/src/internal/util/errorContext.ts", "../../rxjs/src/internal/Subscriber.ts", "../../rxjs/src/internal/symbol/observable.ts", "../../rxjs/src/internal/util/identity.ts", "../../rxjs/src/internal/util/pipe.ts", "../../rxjs/src/internal/Observable.ts", "../../rxjs/src/internal/util/lift.ts", "../../rxjs/src/internal/operators/OperatorSubscriber.ts", "../../rxjs/src/internal/operators/refCount.ts", "../../rxjs/src/internal/observable/ConnectableObservable.ts", "../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../rxjs/src/internal/Subject.ts", "../../rxjs/src/internal/BehaviorSubject.ts", "../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../rxjs/src/internal/ReplaySubject.ts", "../../rxjs/src/internal/AsyncSubject.ts", "../../rxjs/src/internal/scheduler/Action.ts", "../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/Scheduler.ts", "../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/async.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../rxjs/src/internal/observable/empty.ts", "../../rxjs/src/internal/util/isScheduler.ts", "../../rxjs/src/internal/util/args.ts", "../../rxjs/src/internal/util/isArrayLike.ts", "../../rxjs/src/internal/util/isPromise.ts", "../../rxjs/src/internal/util/isInteropObservable.ts", "../../rxjs/src/internal/util/isAsyncIterable.ts", "../../rxjs/src/internal/util/throwUnobservableError.ts", "../../rxjs/src/internal/symbol/iterator.ts", "../../rxjs/src/internal/util/isIterable.ts", "../../rxjs/src/internal/util/isReadableStreamLike.ts", "../../rxjs/src/internal/observable/innerFrom.ts", "../../rxjs/src/internal/util/executeSchedule.ts", "../../rxjs/src/internal/operators/observeOn.ts", "../../rxjs/src/internal/operators/subscribeOn.ts", "../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../rxjs/src/internal/scheduled/scheduled.ts", "../../rxjs/src/internal/observable/from.ts", "../../rxjs/src/internal/observable/of.ts", "../../rxjs/src/internal/observable/throwError.ts", "../../rxjs/src/internal/Notification.ts", "../../rxjs/src/internal/util/isObservable.ts", "../../rxjs/src/internal/util/EmptyError.ts", "../../rxjs/src/internal/firstValueFrom.ts", "../../rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../rxjs/src/internal/util/NotFoundError.ts", "../../rxjs/src/internal/util/SequenceError.ts", "../../rxjs/src/internal/operators/timeout.ts", "../../rxjs/src/internal/operators/map.ts", "../../rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../rxjs/src/internal/observable/never.ts", "../../rxjs/src/internal/util/argsOrArgArray.ts", "../../rxjs/src/internal/operators/filter.ts", "../../rxjs/src/internal/operators/debounceTime.ts", "../../rxjs/src/internal/operators/take.ts", "../../rxjs/src/internal/operators/distinctUntilChanged.ts", "../../@ngneat/elf/index.esm.js"],
  "sourcesContent": ["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n  extendStatics = Object.setPrototypeOf ||\r\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n  return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n  if (typeof b !== \"function\" && b !== null)\r\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n  extendStatics(d, b);\r\n  function __() { this.constructor = d; }\r\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n  __assign = Object.assign || function __assign(t) {\r\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n          s = arguments[i];\r\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n      }\r\n      return t;\r\n  }\r\n  return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n  var t = {};\r\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n      t[p] = s[p];\r\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n              t[p[i]] = s[p[i]];\r\n      }\r\n  return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n  return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n  var _, done = false;\r\n  for (var i = decorators.length - 1; i >= 0; i--) {\r\n      var context = {};\r\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n      if (kind === \"accessor\") {\r\n          if (result === void 0) continue;\r\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n          if (_ = accept(result.get)) descriptor.get = _;\r\n          if (_ = accept(result.set)) descriptor.set = _;\r\n          if (_ = accept(result.init)) initializers.unshift(_);\r\n      }\r\n      else if (_ = accept(result)) {\r\n          if (kind === \"field\") initializers.unshift(_);\r\n          else descriptor[key] = _;\r\n      }\r\n  }\r\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n  done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n  var useValue = arguments.length > 2;\r\n  for (var i = 0; i < initializers.length; i++) {\r\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n  }\r\n  return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n  return new (P || (P = Promise))(function (resolve, reject) {\r\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n  });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n  function verb(n) { return function (v) { return step([n, v]); }; }\r\n  function step(op) {\r\n      if (f) throw new TypeError(\"Generator is already executing.\");\r\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n          if (y = 0, t) op = [op[0] & 2, t.value];\r\n          switch (op[0]) {\r\n              case 0: case 1: t = op; break;\r\n              case 4: _.label++; return { value: op[1], done: false };\r\n              case 5: _.label++; y = op[1]; op = [0]; continue;\r\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n              default:\r\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                  if (t[2]) _.ops.pop();\r\n                  _.trys.pop(); continue;\r\n          }\r\n          op = body.call(thisArg, _);\r\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n  }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n  if (k2 === undefined) k2 = k;\r\n  var desc = Object.getOwnPropertyDescriptor(m, k);\r\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n  }\r\n  Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n  if (k2 === undefined) k2 = k;\r\n  o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n  if (m) return m.call(o);\r\n  if (o && typeof o.length === \"number\") return {\r\n      next: function () {\r\n          if (o && i >= o.length) o = void 0;\r\n          return { value: o && o[i++], done: !o };\r\n      }\r\n  };\r\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n  if (!m) return o;\r\n  var i = m.call(o), r, ar = [], e;\r\n  try {\r\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n  }\r\n  catch (error) { e = { error: error }; }\r\n  finally {\r\n      try {\r\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n      }\r\n      finally { if (e) throw e.error; }\r\n  }\r\n  return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n  for (var ar = [], i = 0; i < arguments.length; i++)\r\n      ar = ar.concat(__read(arguments[i]));\r\n  return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n          r[k] = a[j];\r\n  return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n      if (ar || !(i in from)) {\r\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n          ar[i] = from[i];\r\n      }\r\n  }\r\n  return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n  function fulfill(value) { resume(\"next\", value); }\r\n  function reject(value) { resume(\"throw\", value); }\r\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n  var i, p;\r\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n  var m = o[Symbol.asyncIterator], i;\r\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n  return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n  o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n  ownKeys = Object.getOwnPropertyNames || function (o) {\r\n    var ar = [];\r\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n    return ar;\r\n  };\r\n  return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n  if (mod && mod.__esModule) return mod;\r\n  var result = {};\r\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n  __setModuleDefault(result, mod);\r\n  return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n  return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n  if (value !== null && value !== void 0) {\r\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n    var dispose, inner;\r\n    if (async) {\r\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n      dispose = value[Symbol.asyncDispose];\r\n    }\r\n    if (dispose === void 0) {\r\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n      dispose = value[Symbol.dispose];\r\n      if (async) inner = dispose;\r\n    }\r\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n    env.stack.push({ value: value, dispose: dispose, async: async });\r\n  }\r\n  else if (async) {\r\n    env.stack.push({ async: true });\r\n  }\r\n  return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n  var e = new Error(message);\r\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n  function fail(e) {\r\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n    env.hasError = true;\r\n  }\r\n  var r, s = 0;\r\n  function next() {\r\n    while (r = env.stack.pop()) {\r\n      try {\r\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n        if (r.dispose) {\r\n          var result = r.dispose.call(r.value);\r\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n        }\r\n        else s |= 1;\r\n      }\r\n      catch (e) {\r\n        fail(e);\r\n      }\r\n    }\r\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n    if (env.hasError) throw env.error;\r\n  }\r\n  return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n      });\r\n  }\r\n  return path;\r\n}\r\n\r\nexport default {\r\n  __extends,\r\n  __assign,\r\n  __rest,\r\n  __decorate,\r\n  __param,\r\n  __esDecorate,\r\n  __runInitializers,\r\n  __propKey,\r\n  __setFunctionName,\r\n  __metadata,\r\n  __awaiter,\r\n  __generator,\r\n  __createBinding,\r\n  __exportStar,\r\n  __values,\r\n  __read,\r\n  __spread,\r\n  __spreadArrays,\r\n  __spreadArray,\r\n  __await,\r\n  __asyncGenerator,\r\n  __asyncDelegator,\r\n  __asyncValues,\r\n  __makeTemplateObject,\r\n  __importStar,\r\n  __importDefault,\r\n  __classPrivateFieldGet,\r\n  __classPrivateFieldSet,\r\n  __classPrivateFieldIn,\r\n  __addDisposableResource,\r\n  __disposeResources,\r\n  __rewriteRelativeImportExtension,\r\n};\r\n", "/**\r\n * Returns true if the object is a function.\r\n * @param value The value to check\r\n */\r\nexport function isFunction(value: any): value is (...args: any[]) => any {\r\n  return typeof value === 'function';\r\n}\r\n", "/**\r\n * Used to create Error subclasses until the community moves away from ES5.\r\n *\r\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\r\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\r\n *\r\n * @param createImpl A factory function to create the actual constructor implementation. The returned\r\n * function should be a named function that calls `_super` internally.\r\n */\r\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\r\n  const _super = (instance: any) => {\r\n    Error.call(instance);\r\n    instance.stack = new Error().stack;\r\n  };\r\n\r\n  const ctorFunc = createImpl(_super);\r\n  ctorFunc.prototype = Object.create(Error.prototype);\r\n  ctorFunc.prototype.constructor = ctorFunc;\r\n  return ctorFunc;\r\n}\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface UnsubscriptionError extends Error {\r\n  readonly errors: any[];\r\n}\r\n\r\nexport interface UnsubscriptionErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (errors: any[]): UnsubscriptionError;\r\n}\r\n\r\n/**\r\n * An error thrown when one or more errors have occurred during the\r\n * `unsubscribe` of a {@link Subscription}.\r\n */\r\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\r\n      _super(this);\r\n      this.message = errors\r\n        ? `${errors.length} errors occurred during unsubscription:\r\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\r\n        : '';\r\n      this.name = 'UnsubscriptionError';\r\n      this.errors = errors;\r\n    }\r\n);\r\n", "/**\r\n * Removes an item from an array, mutating it.\r\n * @param arr The array to remove the item from\r\n * @param item The item to remove\r\n */\r\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\r\n  if (arr) {\r\n    const index = arr.indexOf(item);\r\n    0 <= index && arr.splice(index, 1);\r\n  }\r\n}\r\n", "import { isFunction } from './util/isFunction';\r\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\r\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\r\nimport { arrRemove } from './util/arrRemove';\r\n\r\n/**\r\n * Represents a disposable resource, such as the execution of an Observable. A\r\n * Subscription has one important method, `unsubscribe`, that takes no argument\r\n * and just disposes the resource held by the subscription.\r\n *\r\n * Additionally, subscriptions may be grouped together through the `add()`\r\n * method, which will attach a child Subscription to the current Subscription.\r\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\r\n * will be unsubscribed as well.\r\n */\r\nexport class Subscription implements SubscriptionLike {\r\n  public static EMPTY = (() => {\r\n    const empty = new Subscription();\r\n    empty.closed = true;\r\n    return empty;\r\n  })();\r\n\r\n  /**\r\n   * A flag to indicate whether this Subscription has already been unsubscribed.\r\n   */\r\n  public closed = false;\r\n\r\n  private _parentage: Subscription[] | Subscription | null = null;\r\n\r\n  /**\r\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\r\n   * list occurs in the {@link #add} and {@link #remove} methods.\r\n   */\r\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\r\n\r\n  /**\r\n   * @param initialTeardown A function executed first as part of the finalization\r\n   * process that is kicked off when {@link #unsubscribe} is called.\r\n   */\r\n  constructor(private initialTeardown?: () => void) {}\r\n\r\n  /**\r\n   * Disposes the resources held by the subscription. May, for instance, cancel\r\n   * an ongoing Observable execution or cancel any other type of work that\r\n   * started when the Subscription was created.\r\n   */\r\n  unsubscribe(): void {\r\n    let errors: any[] | undefined;\r\n\r\n    if (!this.closed) {\r\n      this.closed = true;\r\n\r\n      // Remove this from it's parents.\r\n      const { _parentage } = this;\r\n      if (_parentage) {\r\n        this._parentage = null;\r\n        if (Array.isArray(_parentage)) {\r\n          for (const parent of _parentage) {\r\n            parent.remove(this);\r\n          }\r\n        } else {\r\n          _parentage.remove(this);\r\n        }\r\n      }\r\n\r\n      const { initialTeardown: initialFinalizer } = this;\r\n      if (isFunction(initialFinalizer)) {\r\n        try {\r\n          initialFinalizer();\r\n        } catch (e) {\r\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\r\n        }\r\n      }\r\n\r\n      const { _finalizers } = this;\r\n      if (_finalizers) {\r\n        this._finalizers = null;\r\n        for (const finalizer of _finalizers) {\r\n          try {\r\n            execFinalizer(finalizer);\r\n          } catch (err) {\r\n            errors = errors ?? [];\r\n            if (err instanceof UnsubscriptionError) {\r\n              errors = [...errors, ...err.errors];\r\n            } else {\r\n              errors.push(err);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (errors) {\r\n        throw new UnsubscriptionError(errors);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\r\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\r\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\r\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\r\n   *\r\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\r\n   * subscription to a any subscription will result in no operation. (A noop).\r\n   *\r\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\r\n   * operation at all. (A noop).\r\n   *\r\n   * `Subscription` instances that are added to this instance will automatically remove themselves\r\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\r\n   * will need to be removed manually with {@link #remove}\r\n   *\r\n   * @param teardown The finalization logic to add to this subscription.\r\n   */\r\n  add(teardown: TeardownLogic): void {\r\n    // Only add the finalizer if it's not undefined\r\n    // and don't add a subscription to itself.\r\n    if (teardown && teardown !== this) {\r\n      if (this.closed) {\r\n        // If this subscription is already closed,\r\n        // execute whatever finalizer is handed to it automatically.\r\n        execFinalizer(teardown);\r\n      } else {\r\n        if (teardown instanceof Subscription) {\r\n          // We don't add closed subscriptions, and we don't add the same subscription\r\n          // twice. Subscription unsubscribe is idempotent.\r\n          if (teardown.closed || teardown._hasParent(this)) {\r\n            return;\r\n          }\r\n          teardown._addParent(this);\r\n        }\r\n        (this._finalizers = this._finalizers ?? []).push(teardown);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks to see if a this subscription already has a particular parent.\r\n   * This will signal that this subscription has already been added to the parent in question.\r\n   * @param parent the parent to check for\r\n   */\r\n  private _hasParent(parent: Subscription) {\r\n    const { _parentage } = this;\r\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\r\n  }\r\n\r\n  /**\r\n   * Adds a parent to this subscription so it can be removed from the parent if it\r\n   * unsubscribes on it's own.\r\n   *\r\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\r\n   * @param parent The parent subscription to add\r\n   */\r\n  private _addParent(parent: Subscription) {\r\n    const { _parentage } = this;\r\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\r\n  }\r\n\r\n  /**\r\n   * Called on a child when it is removed via {@link #remove}.\r\n   * @param parent The parent to remove\r\n   */\r\n  private _removeParent(parent: Subscription) {\r\n    const { _parentage } = this;\r\n    if (_parentage === parent) {\r\n      this._parentage = null;\r\n    } else if (Array.isArray(_parentage)) {\r\n      arrRemove(_parentage, parent);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\r\n   *\r\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\r\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\r\n   * is not a common thing and should be used thoughtfully.\r\n   *\r\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\r\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\r\n   *\r\n   * All finalizer instances are removed to free up memory upon unsubscription.\r\n   *\r\n   * @param teardown The finalizer to remove from this subscription\r\n   */\r\n  remove(teardown: Exclude<TeardownLogic, void>): void {\r\n    const { _finalizers } = this;\r\n    _finalizers && arrRemove(_finalizers, teardown);\r\n\r\n    if (teardown instanceof Subscription) {\r\n      teardown._removeParent(this);\r\n    }\r\n  }\r\n}\r\n\r\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\r\n\r\nexport function isSubscription(value: any): value is Subscription {\r\n  return (\r\n    value instanceof Subscription ||\r\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\r\n  );\r\n}\r\n\r\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\r\n  if (isFunction(finalizer)) {\r\n    finalizer();\r\n  } else {\r\n    finalizer.unsubscribe();\r\n  }\r\n}\r\n", "import { Subscriber } from './Subscriber';\r\nimport { ObservableNotification } from './types';\r\n\r\n/**\r\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\r\n * like how to react on unhandled errors.\r\n */\r\nexport const config: GlobalConfig = {\r\n  onUnhandledError: null,\r\n  onStoppedNotification: null,\r\n  Promise: undefined,\r\n  useDeprecatedSynchronousErrorHandling: false,\r\n  useDeprecatedNextContext: false,\r\n};\r\n\r\n/**\r\n * The global configuration object for RxJS, used to configure things\r\n * like how to react on unhandled errors. Accessible via {@link config}\r\n * object.\r\n */\r\nexport interface GlobalConfig {\r\n  /**\r\n   * A registration point for unhandled errors from RxJS. These are errors that\r\n   * cannot were not handled by consuming code in the usual subscription path. For\r\n   * example, if you have this configured, and you subscribe to an observable without\r\n   * providing an error handler, errors from that subscription will end up here. This\r\n   * will _always_ be called asynchronously on another job in the runtime. This is because\r\n   * we do not want errors thrown in this user-configured handler to interfere with the\r\n   * behavior of the library.\r\n   */\r\n  onUnhandledError: ((err: any) => void) | null;\r\n\r\n  /**\r\n   * A registration point for notifications that cannot be sent to subscribers because they\r\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\r\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\r\n   * might want a different behavior. For example, with sources that attempt to report errors\r\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\r\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\r\n   * we do not want errors thrown in this user-configured handler to interfere with the\r\n   * behavior of the library.\r\n   */\r\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\r\n\r\n  /**\r\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\r\n   * methods.\r\n   *\r\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\r\n   * Promise constructor. If you need a Promise implementation other than native promises,\r\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\r\n   */\r\n  Promise?: PromiseConstructorLike;\r\n\r\n  /**\r\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\r\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\r\n   * call in a try/catch block. It also enables producer interference, a nasty bug\r\n   * where a multicast can be broken for all observers by a downstream consumer with\r\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\r\n   * FOR MIGRATION REASONS.\r\n   *\r\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\r\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\r\n   * behaviors described above. Will be removed in v8.\r\n   */\r\n  useDeprecatedSynchronousErrorHandling: boolean;\r\n\r\n  /**\r\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\r\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\r\n   * to `subscribe`.\r\n   *\r\n   * This is being removed because the performance was severely problematic, and it could also cause\r\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\r\n   * their `this` context overwritten.\r\n   *\r\n   * @deprecated As of version 8, RxJS will no longer support altering the\r\n   * context of next functions provided as part of an observer to Subscribe. Instead,\r\n   * you will have access to a subscription or a signal or token that will allow you to do things like\r\n   * unsubscribe and test closed status. Will be removed in v8.\r\n   */\r\n  useDeprecatedNextContext: boolean;\r\n}\r\n", "import type { TimerHandle } from './timerHandle';\r\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\r\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\r\n\r\ninterface TimeoutProvider {\r\n  setTimeout: SetTimeoutFunction;\r\n  clearTimeout: ClearTimeoutFunction;\r\n  delegate:\r\n    | {\r\n        setTimeout: SetTimeoutFunction;\r\n        clearTimeout: ClearTimeoutFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const timeoutProvider: TimeoutProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setTimeout(handler: () => void, timeout?: number, ...args) {\r\n    const { delegate } = timeoutProvider;\r\n    if (delegate?.setTimeout) {\r\n      return delegate.setTimeout(handler, timeout, ...args);\r\n    }\r\n    return setTimeout(handler, timeout, ...args);\r\n  },\r\n  clearTimeout(handle) {\r\n    const { delegate } = timeoutProvider;\r\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { config } from '../config';\r\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\r\n\r\n/**\r\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\r\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\r\n *\r\n * This should be called whenever there is an error that is out-of-band with the subscription\r\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\r\n *\r\n * @param err the error to report\r\n */\r\nexport function reportUnhandledError(err: any) {\r\n  timeoutProvider.setTimeout(() => {\r\n    const { onUnhandledError } = config;\r\n    if (onUnhandledError) {\r\n      // Execute the user-configured error handler.\r\n      onUnhandledError(err);\r\n    } else {\r\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\r\n      throw err;\r\n    }\r\n  });\r\n}\r\n", "/* tslint:disable:no-empty */\r\nexport function noop() { }\r\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\r\n\r\n/**\r\n * A completion object optimized for memory use and created to be the\r\n * same \"shape\" as other notifications in v8.\r\n * @internal\r\n */\r\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\r\n\r\n/**\r\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\r\n * as other notifications.\r\n * @internal\r\n */\r\nexport function errorNotification(error: any): ErrorNotification {\r\n  return createNotification('E', undefined, error) as any;\r\n}\r\n\r\n/**\r\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\r\n * as other notifications.\r\n * @internal\r\n */\r\nexport function nextNotification<T>(value: T) {\r\n  return createNotification('N', value, undefined) as NextNotification<T>;\r\n}\r\n\r\n/**\r\n * Ensures that all notifications created internally have the same \"shape\" in v8.\r\n *\r\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\r\n * @internal\r\n */\r\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\r\n  return {\r\n    kind,\r\n    value,\r\n    error,\r\n  };\r\n}\r\n", "import { config } from '../config';\r\n\r\nlet context: { errorThrown: boolean; error: any } | null = null;\r\n\r\n/**\r\n * Handles dealing with errors for super-gross mode. Creates a context, in which\r\n * any synchronously thrown errors will be passed to {@link captureError}. Which\r\n * will record the error such that it will be rethrown after the call back is complete.\r\n * TODO: Remove in v8\r\n * @param cb An immediately executed function.\r\n */\r\nexport function errorContext(cb: () => void) {\r\n  if (config.useDeprecatedSynchronousErrorHandling) {\r\n    const isRoot = !context;\r\n    if (isRoot) {\r\n      context = { errorThrown: false, error: null };\r\n    }\r\n    cb();\r\n    if (isRoot) {\r\n      const { errorThrown, error } = context!;\r\n      context = null;\r\n      if (errorThrown) {\r\n        throw error;\r\n      }\r\n    }\r\n  } else {\r\n    // This is the general non-deprecated path for everyone that\r\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\r\n    cb();\r\n  }\r\n}\r\n\r\n/**\r\n * Captures errors only in super-gross mode.\r\n * @param err the error to capture\r\n */\r\nexport function captureError(err: any) {\r\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\r\n    context.errorThrown = true;\r\n    context.error = err;\r\n  }\r\n}\r\n", "import { isFunction } from './util/isFunction';\r\nimport { Observer, ObservableNotification } from './types';\r\nimport { isSubscription, Subscription } from './Subscription';\r\nimport { config } from './config';\r\nimport { reportUnhandledError } from './util/reportUnhandledError';\r\nimport { noop } from './util/noop';\r\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\r\nimport { timeoutProvider } from './scheduler/timeoutProvider';\r\nimport { captureError } from './util/errorContext';\r\n\r\n/**\r\n * Implements the {@link Observer} interface and extends the\r\n * {@link Subscription} class. While the {@link Observer} is the public API for\r\n * consuming the values of an {@link Observable}, all Observers get converted to\r\n * a Subscriber, in order to provide Subscription-like capabilities such as\r\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\r\n * implementing operators, but it is rarely used as a public API.\r\n */\r\nexport class Subscriber<T> extends Subscription implements Observer<T> {\r\n  /**\r\n   * A static factory for a Subscriber, given a (potentially partial) definition\r\n   * of an Observer.\r\n   * @param next The `next` callback of an Observer.\r\n   * @param error The `error` callback of an\r\n   * Observer.\r\n   * @param complete The `complete` callback of an\r\n   * Observer.\r\n   * @return A Subscriber wrapping the (partially defined)\r\n   * Observer represented by the given arguments.\r\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\r\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\r\n   * If you have a specific use case, please file an issue.\r\n   */\r\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\r\n    return new SafeSubscriber(next, error, complete);\r\n  }\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  protected isStopped: boolean = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\r\n\r\n  /**\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\r\n   */\r\n  constructor(destination?: Subscriber<any> | Observer<any>) {\r\n    super();\r\n    if (destination) {\r\n      this.destination = destination;\r\n      // Automatically chain subscriptions together here.\r\n      // if destination is a Subscription, then it is a Subscriber.\r\n      if (isSubscription(destination)) {\r\n        destination.add(this);\r\n      }\r\n    } else {\r\n      this.destination = EMPTY_OBSERVER;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive notifications of type `next` from\r\n   * the Observable, with a value. The Observable may call this method 0 or more\r\n   * times.\r\n   * @param value The `next` value.\r\n   */\r\n  next(value: T): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(nextNotification(value), this);\r\n    } else {\r\n      this._next(value!);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive notifications of type `error` from\r\n   * the Observable, with an attached `Error`. Notifies the Observer that\r\n   * the Observable has experienced an error condition.\r\n   * @param err The `error` exception.\r\n   */\r\n  error(err?: any): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(errorNotification(err), this);\r\n    } else {\r\n      this.isStopped = true;\r\n      this._error(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The {@link Observer} callback to receive a valueless notification of type\r\n   * `complete` from the Observable. Notifies the Observer that the Observable\r\n   * has finished sending push-based notifications.\r\n   */\r\n  complete(): void {\r\n    if (this.isStopped) {\r\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\r\n    } else {\r\n      this.isStopped = true;\r\n      this._complete();\r\n    }\r\n  }\r\n\r\n  unsubscribe(): void {\r\n    if (!this.closed) {\r\n      this.isStopped = true;\r\n      super.unsubscribe();\r\n      this.destination = null!;\r\n    }\r\n  }\r\n\r\n  protected _next(value: T): void {\r\n    this.destination.next(value);\r\n  }\r\n\r\n  protected _error(err: any): void {\r\n    try {\r\n      this.destination.error(err);\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n\r\n  protected _complete(): void {\r\n    try {\r\n      this.destination.complete();\r\n    } finally {\r\n      this.unsubscribe();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This bind is captured here because we want to be able to have\r\n * compatibility with monoid libraries that tend to use a method named\r\n * `bind`. In particular, a library called Monio requires this.\r\n */\r\nconst _bind = Function.prototype.bind;\r\n\r\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\r\n  return _bind.call(fn, thisArg);\r\n}\r\n\r\n/**\r\n * Internal optimization only, DO NOT EXPOSE.\r\n * @internal\r\n */\r\nclass ConsumerObserver<T> implements Observer<T> {\r\n  constructor(private partialObserver: Partial<Observer<T>>) {}\r\n\r\n  next(value: T): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.next) {\r\n      try {\r\n        partialObserver.next(value);\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  error(err: any): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.error) {\r\n      try {\r\n        partialObserver.error(err);\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    } else {\r\n      handleUnhandledError(err);\r\n    }\r\n  }\r\n\r\n  complete(): void {\r\n    const { partialObserver } = this;\r\n    if (partialObserver.complete) {\r\n      try {\r\n        partialObserver.complete();\r\n      } catch (error) {\r\n        handleUnhandledError(error);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class SafeSubscriber<T> extends Subscriber<T> {\r\n  constructor(\r\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\r\n    error?: ((e?: any) => void) | null,\r\n    complete?: (() => void) | null\r\n  ) {\r\n    super();\r\n\r\n    let partialObserver: Partial<Observer<T>>;\r\n    if (isFunction(observerOrNext) || !observerOrNext) {\r\n      // The first argument is a function, not an observer. The next\r\n      // two arguments *could* be observers, or they could be empty.\r\n      partialObserver = {\r\n        next: (observerOrNext ?? undefined) as ((value: T) => void) | undefined,\r\n        error: error ?? undefined,\r\n        complete: complete ?? undefined,\r\n      };\r\n    } else {\r\n      // The first argument is a partial observer.\r\n      let context: any;\r\n      if (this && config.useDeprecatedNextContext) {\r\n        // This is a deprecated path that made `this.unsubscribe()` available in\r\n        // next handler functions passed to subscribe. This only exists behind a flag\r\n        // now, as it is *very* slow.\r\n        context = Object.create(observerOrNext);\r\n        context.unsubscribe = () => this.unsubscribe();\r\n        partialObserver = {\r\n          next: observerOrNext.next && bind(observerOrNext.next, context),\r\n          error: observerOrNext.error && bind(observerOrNext.error, context),\r\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\r\n        };\r\n      } else {\r\n        // The \"normal\" path. Just use the partial observer directly.\r\n        partialObserver = observerOrNext;\r\n      }\r\n    }\r\n\r\n    // Wrap the partial observer to ensure it's a full observer, and\r\n    // make sure proper error handling is accounted for.\r\n    this.destination = new ConsumerObserver(partialObserver);\r\n  }\r\n}\r\n\r\nfunction handleUnhandledError(error: any) {\r\n  if (config.useDeprecatedSynchronousErrorHandling) {\r\n    captureError(error);\r\n  } else {\r\n    // Ideal path, we report this as an unhandled error,\r\n    // which is thrown on a new call stack.\r\n    reportUnhandledError(error);\r\n  }\r\n}\r\n\r\n/**\r\n * An error handler used when no error handler was supplied\r\n * to the SafeSubscriber -- meaning no error handler was supplied\r\n * do the `subscribe` call on our observable.\r\n * @param err The error to handle\r\n */\r\nfunction defaultErrorHandler(err: any) {\r\n  throw err;\r\n}\r\n\r\n/**\r\n * A handler for notifications that cannot be sent to a stopped subscriber.\r\n * @param notification The notification being sent.\r\n * @param subscriber The stopped subscriber.\r\n */\r\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\r\n  const { onStoppedNotification } = config;\r\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\r\n}\r\n\r\n/**\r\n * The observer used as a stub for subscriptions where the user did not\r\n * pass any arguments to `subscribe`. Comes with the default error handling\r\n * behavior.\r\n */\r\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\r\n  closed: true,\r\n  next: noop,\r\n  error: defaultErrorHandler,\r\n  complete: noop,\r\n};\r\n", "/**\r\n * Symbol.observable or a string \"@@observable\". Used for interop\r\n *\r\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\r\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\r\n */\r\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\r\n", "/**\r\n * This function takes one parameter and just returns it. Simply put,\r\n * this is like `<T>(x: T): T => x`.\r\n *\r\n * ## Examples\r\n *\r\n * This is useful in some cases when using things like `mergeMap`\r\n *\r\n * ```ts\r\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\r\n *\r\n * const source$ = interval(1000).pipe(take(5));\r\n *\r\n * const result$ = source$.pipe(\r\n *   map(i => range(i)),\r\n *   mergeMap(identity) // same as mergeMap(x => x)\r\n * );\r\n *\r\n * result$.subscribe({\r\n *   next: console.log\r\n * });\r\n * ```\r\n *\r\n * Or when you want to selectively apply an operator\r\n *\r\n * ```ts\r\n * import { interval, take, identity } from 'rxjs';\r\n *\r\n * const shouldLimit = () => Math.random() < 0.5;\r\n *\r\n * const source$ = interval(1000);\r\n *\r\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\r\n *\r\n * result$.subscribe({\r\n *   next: console.log\r\n * });\r\n * ```\r\n *\r\n * @param x Any value that is returned by this function\r\n * @returns The value passed as the first parameter to this function\r\n */\r\nexport function identity<T>(x: T): T {\r\n  return x;\r\n}\r\n", "import { identity } from './identity';\r\nimport { UnaryFunction } from '../types';\r\n\r\nexport function pipe(): typeof identity;\r\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\r\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\r\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\r\nexport function pipe<T, A, B, C, D>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>\r\n): UnaryFunction<T, D>;\r\nexport function pipe<T, A, B, C, D, E>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>\r\n): UnaryFunction<T, E>;\r\nexport function pipe<T, A, B, C, D, E, F>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>,\r\n  fn6: UnaryFunction<E, F>\r\n): UnaryFunction<T, F>;\r\nexport function pipe<T, A, B, C, D, E, F, G>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>,\r\n  fn6: UnaryFunction<E, F>,\r\n  fn7: UnaryFunction<F, G>\r\n): UnaryFunction<T, G>;\r\nexport function pipe<T, A, B, C, D, E, F, G, H>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>,\r\n  fn6: UnaryFunction<E, F>,\r\n  fn7: UnaryFunction<F, G>,\r\n  fn8: UnaryFunction<G, H>\r\n): UnaryFunction<T, H>;\r\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>,\r\n  fn6: UnaryFunction<E, F>,\r\n  fn7: UnaryFunction<F, G>,\r\n  fn8: UnaryFunction<G, H>,\r\n  fn9: UnaryFunction<H, I>\r\n): UnaryFunction<T, I>;\r\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\r\n  fn1: UnaryFunction<T, A>,\r\n  fn2: UnaryFunction<A, B>,\r\n  fn3: UnaryFunction<B, C>,\r\n  fn4: UnaryFunction<C, D>,\r\n  fn5: UnaryFunction<D, E>,\r\n  fn6: UnaryFunction<E, F>,\r\n  fn7: UnaryFunction<F, G>,\r\n  fn8: UnaryFunction<G, H>,\r\n  fn9: UnaryFunction<H, I>,\r\n  ...fns: UnaryFunction<any, any>[]\r\n): UnaryFunction<T, unknown>;\r\n\r\n/**\r\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\r\n * and uses it to return a value.\r\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\r\n * passes the result to the next one, passes that result to the next one, and so on.  \r\n */\r\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\r\n  return pipeFromArray(fns);\r\n}\r\n\r\n/** @internal */\r\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\r\n  if (fns.length === 0) {\r\n    return identity as UnaryFunction<any, any>;\r\n  }\r\n\r\n  if (fns.length === 1) {\r\n    return fns[0];\r\n  }\r\n\r\n  return function piped(input: T): R {\r\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\r\n  };\r\n}\r\n", "import { Operator } from './Operator';\r\nimport { SafeSubscriber, Subscriber } from './Subscriber';\r\nimport { isSubscription, Subscription } from './Subscription';\r\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\r\nimport { observable as Symbol_observable } from './symbol/observable';\r\nimport { pipeFromArray } from './util/pipe';\r\nimport { config } from './config';\r\nimport { isFunction } from './util/isFunction';\r\nimport { errorContext } from './util/errorContext';\r\n\r\n/**\r\n * A representation of any set of values over any amount of time. This is the most basic building block\r\n * of RxJS.\r\n */\r\nexport class Observable<T> implements Subscribable<T> {\r\n  /**\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  source: Observable<any> | undefined;\r\n\r\n  /**\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  operator: Operator<any, T> | undefined;\r\n\r\n  /**\r\n   * @param subscribe The function that is called when the Observable is\r\n   * initially subscribed to. This function is given a Subscriber, to which new values\r\n   * can be `next`ed, or an `error` method can be called to raise an error, or\r\n   * `complete` can be called to notify of a successful completion.\r\n   */\r\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\r\n    if (subscribe) {\r\n      this._subscribe = subscribe;\r\n    }\r\n  }\r\n\r\n  // HACK: Since TypeScript inherits static properties too, we have to\r\n  // fight against TypeScript here so Subject can have a different static create signature\r\n  /**\r\n   * Creates a new Observable by calling the Observable constructor\r\n   * @param subscribe the subscriber function to be passed to the Observable constructor\r\n   * @return A new observable.\r\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\r\n   */\r\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\r\n    return new Observable<T>(subscribe);\r\n  };\r\n\r\n  /**\r\n   * Creates a new Observable, with this Observable instance as the source, and the passed\r\n   * operator defined as the new observable's operator.\r\n   * @param operator the operator defining the operation to take on the observable\r\n   * @return A new observable with the Operator applied.\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   * If you have implemented an operator using `lift`, it is recommended that you create an\r\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\r\n   * scratch\" section here: https://rxjs.dev/guide/operators\r\n   */\r\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\r\n    const observable = new Observable<R>();\r\n    observable.source = this;\r\n    observable.operator = operator;\r\n    return observable;\r\n  }\r\n\r\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\r\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\r\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\r\n  /**\r\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\r\n   *\r\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\r\n   *\r\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\r\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\r\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\r\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\r\n   * the thought.\r\n   *\r\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\r\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\r\n   * of the following ways.\r\n   *\r\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\r\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\r\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\r\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\r\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\r\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\r\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\r\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\r\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\r\n   * an `error` method to avoid missing thrown errors.\r\n   *\r\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\r\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\r\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\r\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\r\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\r\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\r\n   *\r\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\r\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\r\n   *\r\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\r\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\r\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\r\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\r\n   *\r\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\r\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\r\n   * by default emits all its values synchronously. Always check documentation for how given Observable\r\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\r\n   *\r\n   * #### Examples\r\n   *\r\n   * Subscribe with an {@link guide/observer Observer}\r\n   *\r\n   * ```ts\r\n   * import { of } from 'rxjs';\r\n   *\r\n   * const sumObserver = {\r\n   *   sum: 0,\r\n   *   next(value) {\r\n   *     console.log('Adding: ' + value);\r\n   *     this.sum = this.sum + value;\r\n   *   },\r\n   *   error() {\r\n   *     // We actually could just remove this method,\r\n   *     // since we do not really care about errors right now.\r\n   *   },\r\n   *   complete() {\r\n   *     console.log('Sum equals: ' + this.sum);\r\n   *   }\r\n   * };\r\n   *\r\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\r\n   *   .subscribe(sumObserver);\r\n   *\r\n   * // Logs:\r\n   * // 'Adding: 1'\r\n   * // 'Adding: 2'\r\n   * // 'Adding: 3'\r\n   * // 'Sum equals: 6'\r\n   * ```\r\n   *\r\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\r\n   *\r\n   * ```ts\r\n   * import { of } from 'rxjs'\r\n   *\r\n   * let sum = 0;\r\n   *\r\n   * of(1, 2, 3).subscribe(\r\n   *   value => {\r\n   *     console.log('Adding: ' + value);\r\n   *     sum = sum + value;\r\n   *   },\r\n   *   undefined,\r\n   *   () => console.log('Sum equals: ' + sum)\r\n   * );\r\n   *\r\n   * // Logs:\r\n   * // 'Adding: 1'\r\n   * // 'Adding: 2'\r\n   * // 'Adding: 3'\r\n   * // 'Sum equals: 6'\r\n   * ```\r\n   *\r\n   * Cancel a subscription\r\n   *\r\n   * ```ts\r\n   * import { interval } from 'rxjs';\r\n   *\r\n   * const subscription = interval(1000).subscribe({\r\n   *   next(num) {\r\n   *     console.log(num)\r\n   *   },\r\n   *   complete() {\r\n   *     // Will not be called, even when cancelling subscription.\r\n   *     console.log('completed!');\r\n   *   }\r\n   * });\r\n   *\r\n   * setTimeout(() => {\r\n   *   subscription.unsubscribe();\r\n   *   console.log('unsubscribed!');\r\n   * }, 2500);\r\n   *\r\n   * // Logs:\r\n   * // 0 after 1s\r\n   * // 1 after 2s\r\n   * // 'unsubscribed!' after 2.5s\r\n   * ```\r\n   *\r\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\r\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\r\n   * @param error A handler for a terminal event resulting from an error. If no error handler is provided,\r\n   * the error will be thrown asynchronously as unhandled.\r\n   * @param complete A handler for a terminal event resulting from successful completion.\r\n   * @return A subscription reference to the registered handlers.\r\n   */\r\n  subscribe(\r\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\r\n    error?: ((error: any) => void) | null,\r\n    complete?: (() => void) | null\r\n  ): Subscription {\r\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\r\n\r\n    errorContext(() => {\r\n      const { operator, source } = this;\r\n      subscriber.add(\r\n        operator\r\n          ? // We're dealing with a subscription in the\r\n            // operator chain to one of our lifted operators.\r\n            operator.call(subscriber, source)\r\n          : source\r\n          ? // If `source` has a value, but `operator` does not, something that\r\n            // had intimate knowledge of our API, like our `Subject`, must have\r\n            // set it. We're going to just call `_subscribe` directly.\r\n            this._subscribe(subscriber)\r\n          : // In all other cases, we're likely wrapping a user-provided initializer\r\n            // function, so we need to catch errors and handle them appropriately.\r\n            this._trySubscribe(subscriber)\r\n      );\r\n    });\r\n\r\n    return subscriber;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\r\n    try {\r\n      return this._subscribe(sink);\r\n    } catch (err) {\r\n      // We don't need to return anything in this case,\r\n      // because it's just going to try to `add()` to a subscription\r\n      // above.\r\n      sink.error(err);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\r\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\r\n   *\r\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\r\n   * observable does not complete, you will end up with a promise that is hung up, and\r\n   * potentially all of the state of an async function hanging out in memory. To avoid\r\n   * this situation, look into adding something like {@link timeout}, {@link take},\r\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\r\n   *\r\n   * #### Example\r\n   *\r\n   * ```ts\r\n   * import { interval, take } from 'rxjs';\r\n   *\r\n   * const source$ = interval(1000).pipe(take(4));\r\n   *\r\n   * async function getTotal() {\r\n   *   let total = 0;\r\n   *\r\n   *   await source$.forEach(value => {\r\n   *     total += value;\r\n   *     console.log('observable -> ' + value);\r\n   *   });\r\n   *\r\n   *   return total;\r\n   * }\r\n   *\r\n   * getTotal().then(\r\n   *   total => console.log('Total: ' + total)\r\n   * );\r\n   *\r\n   * // Expected:\r\n   * // 'observable -> 0'\r\n   * // 'observable -> 1'\r\n   * // 'observable -> 2'\r\n   * // 'observable -> 3'\r\n   * // 'Total: 6'\r\n   * ```\r\n   *\r\n   * @param next A handler for each value emitted by the observable.\r\n   * @return A promise that either resolves on observable completion or\r\n   * rejects with the handled error.\r\n   */\r\n  forEach(next: (value: T) => void): Promise<void>;\r\n\r\n  /**\r\n   * @param next a handler for each value emitted by the observable\r\n   * @param promiseCtor a constructor function used to instantiate the Promise\r\n   * @return a promise that either resolves on observable completion or\r\n   *  rejects with the handled error\r\n   * @deprecated Passing a Promise constructor will no longer be available\r\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\r\n   * little benefit. If you need this functionality, it is recommended that you either\r\n   * polyfill Promise, or you create an adapter to convert the returned native promise\r\n   * to whatever promise implementation you wanted. Will be removed in v8.\r\n   */\r\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\r\n\r\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\r\n    promiseCtor = getPromiseCtor(promiseCtor);\r\n\r\n    return new promiseCtor<void>((resolve, reject) => {\r\n      const subscriber = new SafeSubscriber<T>({\r\n        next: (value) => {\r\n          try {\r\n            next(value);\r\n          } catch (err) {\r\n            reject(err);\r\n            subscriber.unsubscribe();\r\n          }\r\n        },\r\n        error: reject,\r\n        complete: resolve,\r\n      });\r\n      this.subscribe(subscriber);\r\n    }) as Promise<void>;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\r\n    return this.source?.subscribe(subscriber);\r\n  }\r\n\r\n  /**\r\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\r\n   * @return This instance of the observable.\r\n   */\r\n  [Symbol_observable]() {\r\n    return this;\r\n  }\r\n\r\n  /* tslint:disable:max-line-length */\r\n  pipe(): Observable<T>;\r\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\r\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\r\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\r\n  pipe<A, B, C, D>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>\r\n  ): Observable<D>;\r\n  pipe<A, B, C, D, E>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>\r\n  ): Observable<E>;\r\n  pipe<A, B, C, D, E, F>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>,\r\n    op6: OperatorFunction<E, F>\r\n  ): Observable<F>;\r\n  pipe<A, B, C, D, E, F, G>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>,\r\n    op6: OperatorFunction<E, F>,\r\n    op7: OperatorFunction<F, G>\r\n  ): Observable<G>;\r\n  pipe<A, B, C, D, E, F, G, H>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>,\r\n    op6: OperatorFunction<E, F>,\r\n    op7: OperatorFunction<F, G>,\r\n    op8: OperatorFunction<G, H>\r\n  ): Observable<H>;\r\n  pipe<A, B, C, D, E, F, G, H, I>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>,\r\n    op6: OperatorFunction<E, F>,\r\n    op7: OperatorFunction<F, G>,\r\n    op8: OperatorFunction<G, H>,\r\n    op9: OperatorFunction<H, I>\r\n  ): Observable<I>;\r\n  pipe<A, B, C, D, E, F, G, H, I>(\r\n    op1: OperatorFunction<T, A>,\r\n    op2: OperatorFunction<A, B>,\r\n    op3: OperatorFunction<B, C>,\r\n    op4: OperatorFunction<C, D>,\r\n    op5: OperatorFunction<D, E>,\r\n    op6: OperatorFunction<E, F>,\r\n    op7: OperatorFunction<F, G>,\r\n    op8: OperatorFunction<G, H>,\r\n    op9: OperatorFunction<H, I>,\r\n    ...operations: OperatorFunction<any, any>[]\r\n  ): Observable<unknown>;\r\n  /* tslint:enable:max-line-length */\r\n\r\n  /**\r\n   * Used to stitch together functional operators into a chain.\r\n   *\r\n   * ## Example\r\n   *\r\n   * ```ts\r\n   * import { interval, filter, map, scan } from 'rxjs';\r\n   *\r\n   * interval(1000)\r\n   *   .pipe(\r\n   *     filter(x => x % 2 === 0),\r\n   *     map(x => x + x),\r\n   *     scan((acc, x) => acc + x)\r\n   *   )\r\n   *   .subscribe(x => console.log(x));\r\n   * ```\r\n   *\r\n   * @return The Observable result of all the operators having been called\r\n   * in the order they were passed in.\r\n   */\r\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\r\n    return pipeFromArray(operations)(this);\r\n  }\r\n\r\n  /* tslint:disable:max-line-length */\r\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\r\n  toPromise(): Promise<T | undefined>;\r\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\r\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\r\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\r\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\r\n  /* tslint:enable:max-line-length */\r\n\r\n  /**\r\n   * Subscribe to this Observable and get a Promise resolving on\r\n   * `complete` with the last emission (if any).\r\n   *\r\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\r\n   * observable does not complete, you will end up with a promise that is hung up, and\r\n   * potentially all of the state of an async function hanging out in memory. To avoid\r\n   * this situation, look into adding something like {@link timeout}, {@link take},\r\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\r\n   *\r\n   * @param [promiseCtor] a constructor function used to instantiate\r\n   * the Promise\r\n   * @return A Promise that resolves with the last value emit, or\r\n   * rejects on an error. If there were no emissions, Promise\r\n   * resolves with undefined.\r\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\r\n   */\r\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\r\n    promiseCtor = getPromiseCtor(promiseCtor);\r\n\r\n    return new promiseCtor((resolve, reject) => {\r\n      let value: T | undefined;\r\n      this.subscribe(\r\n        (x: T) => (value = x),\r\n        (err: any) => reject(err),\r\n        () => resolve(value)\r\n      );\r\n    }) as Promise<T | undefined>;\r\n  }\r\n}\r\n\r\n/**\r\n * Decides between a passed promise constructor from consuming code,\r\n * A default configured promise constructor, and the native promise\r\n * constructor and returns it. If nothing can be found, it will throw\r\n * an error.\r\n * @param promiseCtor The optional promise constructor to passed by consuming code\r\n */\r\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\r\n  return promiseCtor ?? config.Promise ?? Promise;\r\n}\r\n\r\nfunction isObserver<T>(value: any): value is Observer<T> {\r\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\r\n}\r\n\r\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\r\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { OperatorFunction } from '../types';\r\nimport { isFunction } from './isFunction';\r\n\r\n/**\r\n * Used to determine if an object is an Observable with a lift function.\r\n */\r\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\r\n  return isFunction(source?.lift);\r\n}\r\n\r\n/**\r\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\r\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\r\n */\r\nexport function operate<T, R>(\r\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\r\n): OperatorFunction<T, R> {\r\n  return (source: Observable<T>) => {\r\n    if (hasLift(source)) {\r\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\r\n        try {\r\n          return init(liftedSource, this);\r\n        } catch (err) {\r\n          this.error(err);\r\n        }\r\n      });\r\n    }\r\n    throw new TypeError('Unable to lift unknown Observable type');\r\n  };\r\n}\r\n", "import { Subscriber } from '../Subscriber';\r\n\r\n/**\r\n * Creates an instance of an `OperatorSubscriber`.\r\n * @param destination The downstream subscriber.\r\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\r\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\r\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\r\n * and send to the `destination` error handler.\r\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\r\n * this handler are sent to the `destination` error handler.\r\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\r\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\r\n */\r\nexport function createOperatorSubscriber<T>(\r\n  destination: Subscriber<any>,\r\n  onNext?: (value: T) => void,\r\n  onComplete?: () => void,\r\n  onError?: (err: any) => void,\r\n  onFinalize?: () => void\r\n): Subscriber<T> {\r\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\r\n}\r\n\r\n/**\r\n * A generic helper for allowing operators to be created with a Subscriber and\r\n * use closures to capture necessary state from the operator function itself.\r\n */\r\nexport class OperatorSubscriber<T> extends Subscriber<T> {\r\n  /**\r\n   * Creates an instance of an `OperatorSubscriber`.\r\n   * @param destination The downstream subscriber.\r\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\r\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\r\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\r\n   * and send to the `destination` error handler.\r\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\r\n   * this handler are sent to the `destination` error handler.\r\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\r\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\r\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\r\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\r\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\r\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\r\n   */\r\n  constructor(\r\n    destination: Subscriber<any>,\r\n    onNext?: (value: T) => void,\r\n    onComplete?: () => void,\r\n    onError?: (err: any) => void,\r\n    private onFinalize?: () => void,\r\n    private shouldUnsubscribe?: () => boolean\r\n  ) {\r\n    // It's important - for performance reasons - that all of this class's\r\n    // members are initialized and that they are always initialized in the same\r\n    // order. This will ensure that all OperatorSubscriber instances have the\r\n    // same hidden class in V8. This, in turn, will help keep the number of\r\n    // hidden classes involved in property accesses within the base class as\r\n    // low as possible. If the number of hidden classes involved exceeds four,\r\n    // the property accesses will become megamorphic and performance penalties\r\n    // will be incurred - i.e. inline caches won't be used.\r\n    //\r\n    // The reasons for ensuring all instances have the same hidden class are\r\n    // further discussed in this blog post from Benedikt Meurer:\r\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\r\n    super(destination);\r\n    this._next = onNext\r\n      ? function (this: OperatorSubscriber<T>, value: T) {\r\n          try {\r\n            onNext(value);\r\n          } catch (err) {\r\n            destination.error(err);\r\n          }\r\n        }\r\n      : super._next;\r\n    this._error = onError\r\n      ? function (this: OperatorSubscriber<T>, err: any) {\r\n          try {\r\n            onError(err);\r\n          } catch (err) {\r\n            // Send any errors that occur down stream.\r\n            destination.error(err);\r\n          } finally {\r\n            // Ensure finalization.\r\n            this.unsubscribe();\r\n          }\r\n        }\r\n      : super._error;\r\n    this._complete = onComplete\r\n      ? function (this: OperatorSubscriber<T>) {\r\n          try {\r\n            onComplete();\r\n          } catch (err) {\r\n            // Send any errors that occur down stream.\r\n            destination.error(err);\r\n          } finally {\r\n            // Ensure finalization.\r\n            this.unsubscribe();\r\n          }\r\n        }\r\n      : super._complete;\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\r\n      const { closed } = this;\r\n      super.unsubscribe();\r\n      // Execute additional teardown if we have any and we didn't already do so.\r\n      !closed && this.onFinalize?.();\r\n    }\r\n  }\r\n}\r\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\r\n * you can connect to it.\r\n *\r\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\r\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\r\n * unsubscribes from the source. This way you can make sure that everything before the *published*\r\n * refCount has only a single subscription independently of the number of subscribers to the target\r\n * observable.\r\n *\r\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\r\n * (making the observable hot) and the *refCount* operator in a sequence.\r\n *\r\n * ![](refCount.png)\r\n *\r\n * ## Example\r\n *\r\n * In the following example there are two intervals turned into connectable observables\r\n * by using the *publish* operator. The first one uses the *refCount* operator, the\r\n * second one does not use it. You will notice that a connectable observable does nothing\r\n * until you call its connect function.\r\n *\r\n * ```ts\r\n * import { interval, tap, publish, refCount } from 'rxjs';\r\n *\r\n * // Turn the interval observable into a ConnectableObservable (hot)\r\n * const refCountInterval = interval(400).pipe(\r\n *   tap(num => console.log(`refCount ${ num }`)),\r\n *   publish(),\r\n *   refCount()\r\n * );\r\n *\r\n * const publishedInterval = interval(400).pipe(\r\n *   tap(num => console.log(`publish ${ num }`)),\r\n *   publish()\r\n * );\r\n *\r\n * refCountInterval.subscribe();\r\n * refCountInterval.subscribe();\r\n * // 'refCount 0' -----> 'refCount 1' -----> etc\r\n * // All subscriptions will receive the same value and the tap (and\r\n * // every other operator) before the `publish` operator will be executed\r\n * // only once per event independently of the number of subscriptions.\r\n *\r\n * publishedInterval.subscribe();\r\n * // Nothing happens until you call .connect() on the observable.\r\n * ```\r\n *\r\n * @return A function that returns an Observable that automates the connection\r\n * to ConnectableObservable.\r\n * @see {@link ConnectableObservable}\r\n * @see {@link share}\r\n * @see {@link publish}\r\n * @deprecated Replaced with the {@link share} operator. How `share` is used\r\n * will depend on the connectable observable you created just prior to the\r\n * `refCount` operator.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let connection: Subscription | null = null;\r\n\r\n    (source as any)._refCount++;\r\n\r\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\r\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\r\n        connection = null;\r\n        return;\r\n      }\r\n\r\n      ///\r\n      // Compare the local RefCountSubscriber's connection Subscription to the\r\n      // connection Subscription on the shared ConnectableObservable. In cases\r\n      // where the ConnectableObservable source synchronously emits values, and\r\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\r\n      // execution continues to here before the RefCountOperator has a chance to\r\n      // supply the RefCountSubscriber with the shared connection Subscription.\r\n      // For example:\r\n      // ```\r\n      // range(0, 10).pipe(\r\n      //   publish(),\r\n      //   refCount(),\r\n      //   take(5),\r\n      // )\r\n      // .subscribe();\r\n      // ```\r\n      // In order to account for this case, RefCountSubscriber should only dispose\r\n      // the ConnectableObservable's shared connection Subscription if the\r\n      // connection Subscription exists, *and* either:\r\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\r\n      //      Subscription yet, or,\r\n      //   b. RefCountSubscriber's connection Subscription reference is identical\r\n      //      to the shared connection Subscription\r\n      ///\r\n\r\n      const sharedConnection = (source as any)._connection;\r\n      const conn = connection;\r\n      connection = null;\r\n\r\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\r\n        sharedConnection.unsubscribe();\r\n      }\r\n\r\n      subscriber.unsubscribe();\r\n    });\r\n\r\n    source.subscribe(refCounter);\r\n\r\n    if (!refCounter.closed) {\r\n      connection = (source as ConnectableObservable<T>).connect();\r\n    }\r\n  });\r\n}\r\n", "import { Subject } from '../Subject';\r\nimport { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { Subscription } from '../Subscription';\r\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\r\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\r\nimport { hasLift } from '../util/lift';\r\n\r\n/**\r\n * @class ConnectableObservable<T>\r\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\r\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\r\n * instead.\r\n * Details: https://rxjs.dev/deprecations/multicasting\r\n */\r\nexport class ConnectableObservable<T> extends Observable<T> {\r\n  protected _subject: Subject<T> | null = null;\r\n  protected _refCount: number = 0;\r\n  protected _connection: Subscription | null = null;\r\n\r\n  /**\r\n   * @param source The source observable\r\n   * @param subjectFactory The factory that creates the subject used internally.\r\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\r\n   * `new ConnectableObservable(source, factory)` is equivalent to\r\n   * `connectable(source, { connector: factory })`.\r\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\r\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\r\n   * `source.pipe(share({ connector: factory }))`.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\r\n    super();\r\n    // If we have lift, monkey patch that here. This is done so custom observable\r\n    // types will compose through multicast. Otherwise the resulting observable would\r\n    // simply be an instance of `ConnectableObservable`.\r\n    if (hasLift(source)) {\r\n      this.lift = source.lift;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>) {\r\n    return this.getSubject().subscribe(subscriber);\r\n  }\r\n\r\n  protected getSubject(): Subject<T> {\r\n    const subject = this._subject;\r\n    if (!subject || subject.isStopped) {\r\n      this._subject = this.subjectFactory();\r\n    }\r\n    return this._subject!;\r\n  }\r\n\r\n  protected _teardown() {\r\n    this._refCount = 0;\r\n    const { _connection } = this;\r\n    this._subject = this._connection = null;\r\n    _connection?.unsubscribe();\r\n  }\r\n\r\n  /**\r\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  connect(): Subscription {\r\n    let connection = this._connection;\r\n    if (!connection) {\r\n      connection = this._connection = new Subscription();\r\n      const subject = this.getSubject();\r\n      connection.add(\r\n        this.source.subscribe(\r\n          createOperatorSubscriber(\r\n            subject as any,\r\n            undefined,\r\n            () => {\r\n              this._teardown();\r\n              subject.complete();\r\n            },\r\n            (err) => {\r\n              this._teardown();\r\n              subject.error(err);\r\n            },\r\n            () => this._teardown()\r\n          )\r\n        )\r\n      );\r\n\r\n      if (connection.closed) {\r\n        this._connection = null;\r\n        connection = Subscription.EMPTY;\r\n      }\r\n    }\r\n    return connection;\r\n  }\r\n\r\n  /**\r\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\r\n   * Details: https://rxjs.dev/deprecations/multicasting\r\n   */\r\n  refCount(): Observable<T> {\r\n    return higherOrderRefCount()(this) as Observable<T>;\r\n  }\r\n}\r\n", "import { TimestampProvider } from '../types';\r\n\r\ninterface PerformanceTimestampProvider extends TimestampProvider {\r\n  delegate: TimestampProvider | undefined;\r\n}\r\n\r\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\r\n  now() {\r\n    // Use the variable rather than `this` so that the function can be called\r\n    // without being bound to the provider.\r\n    return (performanceTimestampProvider.delegate || performance).now();\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Subscription } from '../Subscription';\r\n\r\ninterface AnimationFrameProvider {\r\n  schedule(callback: FrameRequestCallback): Subscription;\r\n  requestAnimationFrame: typeof requestAnimationFrame;\r\n  cancelAnimationFrame: typeof cancelAnimationFrame;\r\n  delegate:\r\n    | {\r\n        requestAnimationFrame: typeof requestAnimationFrame;\r\n        cancelAnimationFrame: typeof cancelAnimationFrame;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const animationFrameProvider: AnimationFrameProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  schedule(callback) {\r\n    let request = requestAnimationFrame;\r\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\r\n    const { delegate } = animationFrameProvider;\r\n    if (delegate) {\r\n      request = delegate.requestAnimationFrame;\r\n      cancel = delegate.cancelAnimationFrame;\r\n    }\r\n    const handle = request((timestamp) => {\r\n      // Clear the cancel function. The request has been fulfilled, so\r\n      // attempting to cancel the request upon unsubscription would be\r\n      // pointless.\r\n      cancel = undefined;\r\n      callback(timestamp);\r\n    });\r\n    return new Subscription(() => cancel?.(handle));\r\n  },\r\n  requestAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\r\n  },\r\n  cancelAnimationFrame(...args) {\r\n    const { delegate } = animationFrameProvider;\r\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Observable } from '../../Observable';\r\nimport { TimestampProvider } from '../../types';\r\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\r\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\r\n\r\n/**\r\n * An observable of animation frames\r\n *\r\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\r\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\r\n *\r\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\r\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\r\n * should not be much different or have more overhead than looping over an array of events during\r\n * a single animation frame. However, if for some reason the developer would like to ensure the\r\n * execution of animation-related handlers are all executed during the same task by the engine,\r\n * the `share` operator can be used.\r\n *\r\n * This is useful for setting up animations with RxJS.\r\n *\r\n * ## Examples\r\n *\r\n * Tweening a div to move it on the screen\r\n *\r\n * ```ts\r\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\r\n *\r\n * function tween(start: number, end: number, duration: number) {\r\n *   const diff = end - start;\r\n *   return animationFrames().pipe(\r\n *     // Figure out what percentage of time has passed\r\n *     map(({ elapsed }) => elapsed / duration),\r\n *     // Take the vector while less than 100%\r\n *     takeWhile(v => v < 1),\r\n *     // Finish with 100%\r\n *     endWith(1),\r\n *     // Calculate the distance traveled between start and end\r\n *     map(v => v * diff + start)\r\n *   );\r\n * }\r\n *\r\n * // Setup a div for us to move around\r\n * const div = document.createElement('div');\r\n * document.body.appendChild(div);\r\n * div.style.position = 'absolute';\r\n * div.style.width = '40px';\r\n * div.style.height = '40px';\r\n * div.style.backgroundColor = 'lime';\r\n * div.style.transform = 'translate3d(10px, 0, 0)';\r\n *\r\n * tween(10, 200, 4000).subscribe(x => {\r\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\r\n * });\r\n * ```\r\n *\r\n * Providing a custom timestamp provider\r\n *\r\n * ```ts\r\n * import { animationFrames, TimestampProvider } from 'rxjs';\r\n *\r\n * // A custom timestamp provider\r\n * let now = 0;\r\n * const customTSProvider: TimestampProvider = {\r\n *   now() { return now++; }\r\n * };\r\n *\r\n * const source$ = animationFrames(customTSProvider);\r\n *\r\n * // Log increasing numbers 0...1...2... on every animation frame.\r\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\r\n * ```\r\n *\r\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\r\n */\r\nexport function animationFrames(timestampProvider?: TimestampProvider) {\r\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\r\n}\r\n\r\n/**\r\n * Does the work of creating the observable for `animationFrames`.\r\n * @param timestampProvider The timestamp provider to use to create the observable\r\n */\r\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\r\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\r\n    // If no timestamp provider is specified, use performance.now() - as it\r\n    // will return timestamps 'compatible' with those passed to the run\r\n    // callback and won't be affected by NTP adjustments, etc.\r\n    const provider = timestampProvider || performanceTimestampProvider;\r\n\r\n    // Capture the start time upon subscription, as the run callback can remain\r\n    // queued for a considerable period of time and the elapsed time should\r\n    // represent the time elapsed since subscription - not the time since the\r\n    // first rendered animation frame.\r\n    const start = provider.now();\r\n\r\n    let id = 0;\r\n    const run = () => {\r\n      if (!subscriber.closed) {\r\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\r\n          id = 0;\r\n          // Use the provider's timestamp to calculate the elapsed time. Note that\r\n          // this means - if the caller hasn't passed a provider - that\r\n          // performance.now() will be used instead of the timestamp that was\r\n          // passed to the run callback. The reason for this is that the timestamp\r\n          // passed to the callback can be earlier than the start time, as it\r\n          // represents the time at which the browser decided it would render any\r\n          // queued frames - and that time can be earlier the captured start time.\r\n          const now = provider.now();\r\n          subscriber.next({\r\n            timestamp: timestampProvider ? now : timestamp,\r\n            elapsed: now - start,\r\n          });\r\n          run();\r\n        });\r\n      }\r\n    };\r\n\r\n    run();\r\n\r\n    return () => {\r\n      if (id) {\r\n        animationFrameProvider.cancelAnimationFrame(id);\r\n      }\r\n    };\r\n  });\r\n}\r\n\r\n/**\r\n * In the common case, where the timestamp provided by the rAF API is used,\r\n * we use this shared observable to reduce overhead.\r\n */\r\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface ObjectUnsubscribedError extends Error {}\r\n\r\nexport interface ObjectUnsubscribedErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): ObjectUnsubscribedError;\r\n}\r\n\r\n/**\r\n * An error thrown when an action is invalid because the object has been\r\n * unsubscribed.\r\n *\r\n * @see {@link Subject}\r\n * @see {@link BehaviorSubject}\r\n *\r\n * @class ObjectUnsubscribedError\r\n */\r\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function ObjectUnsubscribedErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'ObjectUnsubscribedError';\r\n      this.message = 'object unsubscribed';\r\n    }\r\n);\r\n", "import { Operator } from './Operator';\r\nimport { Observable } from './Observable';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\r\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\r\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\r\nimport { arrRemove } from './util/arrRemove';\r\nimport { errorContext } from './util/errorContext';\r\n\r\n/**\r\n * A Subject is a special type of Observable that allows values to be\r\n * multicasted to many Observers. Subjects are like EventEmitters.\r\n *\r\n * Every Subject is an Observable and an Observer. You can subscribe to a\r\n * Subject, and you can call next to feed values as well as error and complete.\r\n */\r\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\r\n  closed = false;\r\n\r\n  private currentObservers: Observer<T>[] | null = null;\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  observers: Observer<T>[] = [];\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  isStopped = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  hasError = false;\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  thrownError: any = null;\r\n\r\n  /**\r\n   * Creates a \"subject\" by basically gluing an observer to an observable.\r\n   *\r\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\r\n   */\r\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\r\n    return new AnonymousSubject<T>(destination, source);\r\n  };\r\n\r\n  constructor() {\r\n    // NOTE: This must be here to obscure Observable's constructor.\r\n    super();\r\n  }\r\n\r\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n  lift<R>(operator: Operator<T, R>): Observable<R> {\r\n    const subject = new AnonymousSubject(this, this);\r\n    subject.operator = operator as any;\r\n    return subject as any;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _throwIfClosed() {\r\n    if (this.closed) {\r\n      throw new ObjectUnsubscribedError();\r\n    }\r\n  }\r\n\r\n  next(value: T) {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        if (!this.currentObservers) {\r\n          this.currentObservers = Array.from(this.observers);\r\n        }\r\n        for (const observer of this.currentObservers) {\r\n          observer.next(value);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  error(err: any) {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        this.hasError = this.isStopped = true;\r\n        this.thrownError = err;\r\n        const { observers } = this;\r\n        while (observers.length) {\r\n          observers.shift()!.error(err);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  complete() {\r\n    errorContext(() => {\r\n      this._throwIfClosed();\r\n      if (!this.isStopped) {\r\n        this.isStopped = true;\r\n        const { observers } = this;\r\n        while (observers.length) {\r\n          observers.shift()!.complete();\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  unsubscribe() {\r\n    this.isStopped = this.closed = true;\r\n    this.observers = this.currentObservers = null!;\r\n  }\r\n\r\n  get observed() {\r\n    return this.observers?.length > 0;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\r\n    this._throwIfClosed();\r\n    return super._trySubscribe(subscriber);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    this._throwIfClosed();\r\n    this._checkFinalizedStatuses(subscriber);\r\n    return this._innerSubscribe(subscriber);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\r\n    const { hasError, isStopped, observers } = this;\r\n    if (hasError || isStopped) {\r\n      return EMPTY_SUBSCRIPTION;\r\n    }\r\n    this.currentObservers = null;\r\n    observers.push(subscriber);\r\n    return new Subscription(() => {\r\n      this.currentObservers = null;\r\n      arrRemove(observers, subscriber);\r\n    });\r\n  }\r\n\r\n  /** @internal */\r\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\r\n    const { hasError, thrownError, isStopped } = this;\r\n    if (hasError) {\r\n      subscriber.error(thrownError);\r\n    } else if (isStopped) {\r\n      subscriber.complete();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a new Observable with this Subject as the source. You can do this\r\n   * to create custom Observer-side logic of the Subject and conceal it from\r\n   * code that uses the Observable.\r\n   * @return Observable that this Subject casts to.\r\n   */\r\n  asObservable(): Observable<T> {\r\n    const observable: any = new Observable<T>();\r\n    observable.source = this;\r\n    return observable;\r\n  }\r\n}\r\n\r\nexport class AnonymousSubject<T> extends Subject<T> {\r\n  constructor(\r\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\r\n    public destination?: Observer<T>,\r\n    source?: Observable<T>\r\n  ) {\r\n    super();\r\n    this.source = source;\r\n  }\r\n\r\n  next(value: T) {\r\n    this.destination?.next?.(value);\r\n  }\r\n\r\n  error(err: any) {\r\n    this.destination?.error?.(err);\r\n  }\r\n\r\n  complete() {\r\n    this.destination?.complete?.();\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\r\n  }\r\n}\r\n", "import { Subject } from './Subject';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription } from './Subscription';\r\n\r\n/**\r\n * A variant of Subject that requires an initial value and emits its current\r\n * value whenever it is subscribed to.\r\n */\r\nexport class BehaviorSubject<T> extends Subject<T> {\r\n  constructor(private _value: T) {\r\n    super();\r\n  }\r\n\r\n  get value(): T {\r\n    return this.getValue();\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    const subscription = super._subscribe(subscriber);\r\n    !subscription.closed && subscriber.next(this._value);\r\n    return subscription;\r\n  }\r\n\r\n  getValue(): T {\r\n    const { hasError, thrownError, _value } = this;\r\n    if (hasError) {\r\n      throw thrownError;\r\n    }\r\n    this._throwIfClosed();\r\n    return _value;\r\n  }\r\n\r\n  next(value: T): void {\r\n    super.next((this._value = value));\r\n  }\r\n}\r\n", "import { TimestampProvider } from '../types';\r\n\r\ninterface DateTimestampProvider extends TimestampProvider {\r\n  delegate: TimestampProvider | undefined;\r\n}\r\n\r\nexport const dateTimestampProvider: DateTimestampProvider = {\r\n  now() {\r\n    // Use the variable rather than `this` so that the function can be called\r\n    // without being bound to the provider.\r\n    return (dateTimestampProvider.delegate || Date).now();\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Subject } from './Subject';\r\nimport { TimestampProvider } from './types';\r\nimport { Subscriber } from './Subscriber';\r\nimport { Subscription } from './Subscription';\r\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\r\n\r\n/**\r\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\r\n *\r\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\r\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\r\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\r\n *\r\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\r\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\r\n * error if it has observed an error.\r\n *\r\n * There are two main configuration items to be concerned with:\r\n *\r\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\r\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\r\n *\r\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\r\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\r\n *\r\n * ### Differences with BehaviorSubject\r\n *\r\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\r\n *\r\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\r\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\r\n *\r\n * @see {@link Subject}\r\n * @see {@link BehaviorSubject}\r\n * @see {@link shareReplay}\r\n */\r\nexport class ReplaySubject<T> extends Subject<T> {\r\n  private _buffer: (T | number)[] = [];\r\n  private _infiniteTimeWindow = true;\r\n\r\n  /**\r\n   * @param _bufferSize The size of the buffer to replay on subscription\r\n   * @param _windowTime The amount of time the buffered items will stay buffered\r\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\r\n   * calculate the amount of time something has been buffered.\r\n   */\r\n  constructor(\r\n    private _bufferSize = Infinity,\r\n    private _windowTime = Infinity,\r\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\r\n  ) {\r\n    super();\r\n    this._infiniteTimeWindow = _windowTime === Infinity;\r\n    this._bufferSize = Math.max(1, _bufferSize);\r\n    this._windowTime = Math.max(1, _windowTime);\r\n  }\r\n\r\n  next(value: T): void {\r\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\r\n    if (!isStopped) {\r\n      _buffer.push(value);\r\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\r\n    }\r\n    this._trimBuffer();\r\n    super.next(value);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\r\n    this._throwIfClosed();\r\n    this._trimBuffer();\r\n\r\n    const subscription = this._innerSubscribe(subscriber);\r\n\r\n    const { _infiniteTimeWindow, _buffer } = this;\r\n    // We use a copy here, so reentrant code does not mutate our array while we're\r\n    // emitting it to a new subscriber.\r\n    const copy = _buffer.slice();\r\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\r\n      subscriber.next(copy[i] as T);\r\n    }\r\n\r\n    this._checkFinalizedStatuses(subscriber);\r\n\r\n    return subscription;\r\n  }\r\n\r\n  private _trimBuffer() {\r\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\r\n    // If we don't have an infinite buffer size, and we're over the length,\r\n    // use splice to truncate the old buffer values off. Note that we have to\r\n    // double the size for instances where we're not using an infinite time window\r\n    // because we're storing the values and the timestamps in the same array.\r\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\r\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\r\n\r\n    // Now, if we're not in an infinite time window, remove all values where the time is\r\n    // older than what is allowed.\r\n    if (!_infiniteTimeWindow) {\r\n      const now = _timestampProvider.now();\r\n      let last = 0;\r\n      // Search the array for the first timestamp that isn't expired and\r\n      // truncate the buffer up to that point.\r\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\r\n        last = i;\r\n      }\r\n      last && _buffer.splice(0, last + 1);\r\n    }\r\n  }\r\n}\r\n", "import { Subject } from './Subject';\r\nimport { Subscriber } from './Subscriber';\r\n\r\n/**\r\n * A variant of Subject that only emits a value when it completes. It will emit\r\n * its latest value to all its observers on completion.\r\n */\r\nexport class AsyncSubject<T> extends Subject<T> {\r\n  private _value: T | null = null;\r\n  private _hasValue = false;\r\n  private _isComplete = false;\r\n\r\n  /** @internal */\r\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\r\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\r\n    if (hasError) {\r\n      subscriber.error(thrownError);\r\n    } else if (isStopped || _isComplete) {\r\n      _hasValue && subscriber.next(_value!);\r\n      subscriber.complete();\r\n    }\r\n  }\r\n\r\n  next(value: T): void {\r\n    if (!this.isStopped) {\r\n      this._value = value;\r\n      this._hasValue = true;\r\n    }\r\n  }\r\n\r\n  complete(): void {\r\n    const { _hasValue, _value, _isComplete } = this;\r\n    if (!_isComplete) {\r\n      this._isComplete = true;\r\n      _hasValue && super.next(_value!);\r\n      super.complete();\r\n    }\r\n  }\r\n}\r\n", "import { Scheduler } from '../Scheduler';\r\nimport { Subscription } from '../Subscription';\r\nimport { SchedulerAction } from '../types';\r\n\r\n/**\r\n * A unit of work to be executed in a `scheduler`. An action is typically\r\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\r\n * themselves about creating and manipulating an Action.\r\n *\r\n * ```ts\r\n * class Action<T> extends Subscription {\r\n *   new (scheduler: Scheduler, work: (state?: T) => void);\r\n *   schedule(state?: T, delay: number = 0): Subscription;\r\n * }\r\n * ```\r\n */\r\nexport class Action<T> extends Subscription {\r\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super();\r\n  }\r\n  /**\r\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\r\n   * some context object, `state`. May happen at some point in the future,\r\n   * according to the `delay` parameter, if specified.\r\n   * @param state Some contextual data that the `work` function uses when called by the\r\n   * Scheduler.\r\n   * @param delay Time to wait before executing the work, where the time unit is implicit\r\n   * and defined by the Scheduler.\r\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\r\n   */\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    return this;\r\n  }\r\n}\r\n", "import type { TimerHandle } from './timerHandle';\r\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\r\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\r\n\r\ninterface IntervalProvider {\r\n  setInterval: SetIntervalFunction;\r\n  clearInterval: ClearIntervalFunction;\r\n  delegate:\r\n    | {\r\n        setInterval: SetIntervalFunction;\r\n        clearInterval: ClearIntervalFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const intervalProvider: IntervalProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setInterval(handler: () => void, timeout?: number, ...args) {\r\n    const { delegate } = intervalProvider;\r\n    if (delegate?.setInterval) {\r\n      return delegate.setInterval(handler, timeout, ...args);\r\n    }\r\n    return setInterval(handler, timeout, ...args);\r\n  },\r\n  clearInterval(handle) {\r\n    const { delegate } = intervalProvider;\r\n    return (delegate?.clearInterval || clearInterval)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { Action } from './Action';\r\nimport { SchedulerAction } from '../types';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { intervalProvider } from './intervalProvider';\r\nimport { arrRemove } from '../util/arrRemove';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsyncAction<T> extends Action<T> {\r\n  public id: TimerHandle | undefined;\r\n  public state?: T;\r\n  // @ts-ignore: Property has no initializer and is not definitely assigned\r\n  public delay: number;\r\n  protected pending: boolean = false;\r\n\r\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (this.closed) {\r\n      return this;\r\n    }\r\n\r\n    // Always replace the current state with the new state.\r\n    this.state = state;\r\n\r\n    const id = this.id;\r\n    const scheduler = this.scheduler;\r\n\r\n    //\r\n    // Important implementation note:\r\n    //\r\n    // Actions only execute once by default, unless rescheduled from within the\r\n    // scheduled callback. This allows us to implement single and repeat\r\n    // actions via the same code path, without adding API surface area, as well\r\n    // as mimic traditional recursion but across asynchronous boundaries.\r\n    //\r\n    // However, JS runtimes and timers distinguish between intervals achieved by\r\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\r\n    // serial `setTimeout` calls can be individually delayed, which delays\r\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\r\n    // guarantee the interval callback will be invoked more precisely to the\r\n    // interval period, regardless of load.\r\n    //\r\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\r\n    // If the action reschedules itself with the same delay, the interval is not\r\n    // canceled. If the action doesn't reschedule, or reschedules with a\r\n    // different delay, the interval will be canceled after scheduled callback\r\n    // execution.\r\n    //\r\n    if (id != null) {\r\n      this.id = this.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Set the pending flag indicating that this action has been scheduled, or\r\n    // has recursively rescheduled itself.\r\n    this.pending = true;\r\n\r\n    this.delay = delay;\r\n    // If this action has already an async Id, don't request a new one.\r\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\r\n\r\n    return this;\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\r\n  }\r\n\r\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\r\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\r\n    if (delay != null && this.delay === delay && this.pending === false) {\r\n      return id;\r\n    }\r\n    // Otherwise, if the action's delay time is different from the current delay,\r\n    // or the action has been rescheduled before it's executed, clear the interval id\r\n    if (id != null) {\r\n      intervalProvider.clearInterval(id);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Immediately executes this action and the `work` it contains.\r\n   */\r\n  public execute(state: T, delay: number): any {\r\n    if (this.closed) {\r\n      return new Error('executing a cancelled action');\r\n    }\r\n\r\n    this.pending = false;\r\n    const error = this._execute(state, delay);\r\n    if (error) {\r\n      return error;\r\n    } else if (this.pending === false && this.id != null) {\r\n      // Dequeue if the action didn't reschedule itself. Don't call\r\n      // unsubscribe(), because the action could reschedule later.\r\n      // For example:\r\n      // ```\r\n      // scheduler.schedule(function doWork(counter) {\r\n      //   /* ... I'm a busy worker bee ... */\r\n      //   var originalAction = this;\r\n      //   /* wait 100ms before rescheduling the action */\r\n      //   setTimeout(function () {\r\n      //     originalAction.schedule(counter + 1);\r\n      //   }, 100);\r\n      // }, 1000);\r\n      // ```\r\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\r\n    }\r\n  }\r\n\r\n  protected _execute(state: T, _delay: number): any {\r\n    let errored: boolean = false;\r\n    let errorValue: any;\r\n    try {\r\n      this.work(state);\r\n    } catch (e) {\r\n      errored = true;\r\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\r\n      // return here, we can't have it return \"\" or 0 or false.\r\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\r\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\r\n    }\r\n    if (errored) {\r\n      this.unsubscribe();\r\n      return errorValue;\r\n    }\r\n  }\r\n\r\n  unsubscribe() {\r\n    if (!this.closed) {\r\n      const { id, scheduler } = this;\r\n      const { actions } = scheduler;\r\n\r\n      this.work = this.state = this.scheduler = null!;\r\n      this.pending = false;\r\n\r\n      arrRemove(actions, this);\r\n      if (id != null) {\r\n        this.id = this.recycleAsyncId(scheduler, id, null);\r\n      }\r\n\r\n      this.delay = null!;\r\n      super.unsubscribe();\r\n    }\r\n  }\r\n}\r\n", "let nextHandle = 1;\r\n// The promise needs to be created lazily otherwise it won't be patched by Zones\r\nlet resolved: Promise<any>;\r\nconst activeHandles: { [key: number]: any } = {};\r\n\r\n/**\r\n * Finds the handle in the list of active handles, and removes it.\r\n * Returns `true` if found, `false` otherwise. Used both to clear\r\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\r\n */\r\nfunction findAndClearHandle(handle: number): boolean {\r\n  if (handle in activeHandles) {\r\n    delete activeHandles[handle];\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Helper functions to schedule and unschedule microtasks.\r\n */\r\nexport const Immediate = {\r\n  setImmediate(cb: () => void): number {\r\n    const handle = nextHandle++;\r\n    activeHandles[handle] = true;\r\n    if (!resolved) {\r\n      resolved = Promise.resolve();\r\n    }\r\n    resolved.then(() => findAndClearHandle(handle) && cb());\r\n    return handle;\r\n  },\r\n\r\n  clearImmediate(handle: number): void {\r\n    findAndClearHandle(handle);\r\n  },\r\n};\r\n\r\n/**\r\n * Used for internal testing purposes only. Do not export from library.\r\n */\r\nexport const TestTools = {\r\n  pending() {\r\n    return Object.keys(activeHandles).length;\r\n  }\r\n};\r\n", "import { Immediate } from '../util/Immediate';\r\nimport type { TimerHandle } from './timerHandle';\r\nconst { setImmediate, clearImmediate } = Immediate;\r\n\r\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\r\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\r\n\r\ninterface ImmediateProvider {\r\n  setImmediate: SetImmediateFunction;\r\n  clearImmediate: ClearImmediateFunction;\r\n  delegate:\r\n    | {\r\n        setImmediate: SetImmediateFunction;\r\n        clearImmediate: ClearImmediateFunction;\r\n      }\r\n    | undefined;\r\n}\r\n\r\nexport const immediateProvider: ImmediateProvider = {\r\n  // When accessing the delegate, use the variable rather than `this` so that\r\n  // the functions can be called without being bound to the provider.\r\n  setImmediate(...args) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.setImmediate || setImmediate)(...args);\r\n  },\r\n  clearImmediate(handle) {\r\n    const { delegate } = immediateProvider;\r\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\r\n  },\r\n  delegate: undefined,\r\n};\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { immediateProvider } from './immediateProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsapAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If a microtask has already been scheduled, don't schedule another\r\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\r\n    // the current scheduled microtask id.\r\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested microtask and set the scheduled flag to undefined\r\n    // so the next AsapAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && actions[actions.length - 1]?.id !== id) {\r\n      immediateProvider.clearImmediate(id);\r\n      if (scheduler._scheduled === id) {\r\n        scheduler._scheduled = undefined;\r\n      }\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { Action } from './scheduler/Action';\r\nimport { Subscription } from './Subscription';\r\nimport { SchedulerLike, SchedulerAction } from './types';\r\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\r\n\r\n/**\r\n * An execution context and a data structure to order tasks and schedule their\r\n * execution. Provides a notion of (potentially virtual) time, through the\r\n * `now()` getter method.\r\n *\r\n * Each unit of work in a Scheduler is called an `Action`.\r\n *\r\n * ```ts\r\n * class Scheduler {\r\n *   now(): number;\r\n *   schedule(work, delay?, state?): Subscription;\r\n * }\r\n * ```\r\n *\r\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\r\n * should not be used directly. Rather, create your own class and implement\r\n * {@link SchedulerLike}. Will be made internal in v8.\r\n */\r\nexport class Scheduler implements SchedulerLike {\r\n  public static now: () => number = dateTimestampProvider.now;\r\n\r\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\r\n    this.now = now;\r\n  }\r\n\r\n  /**\r\n   * A getter method that returns a number representing the current time\r\n   * (at the time this function was called) according to the scheduler's own\r\n   * internal clock.\r\n   * @return A number that represents the current time. May or may not\r\n   * have a relation to wall-clock time. May or may not refer to a time unit\r\n   * (e.g. milliseconds).\r\n   */\r\n  public now: () => number;\r\n\r\n  /**\r\n   * Schedules a function, `work`, for execution. May happen at some point in\r\n   * the future, according to the `delay` parameter, if specified. May be passed\r\n   * some context object, `state`, which will be passed to the `work` function.\r\n   *\r\n   * The given arguments will be processed an stored as an Action object in a\r\n   * queue of actions.\r\n   *\r\n   * @param work A function representing a task, or some unit of work to be\r\n   * executed by the Scheduler.\r\n   * @param delay Time to wait before executing the work, where the time unit is\r\n   * implicit and defined by the Scheduler itself.\r\n   * @param state Some contextual data that the `work` function uses when called\r\n   * by the Scheduler.\r\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\r\n   */\r\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\r\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\r\n  }\r\n}\r\n", "import { Scheduler } from '../Scheduler';\r\nimport { Action } from './Action';\r\nimport { AsyncAction } from './AsyncAction';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AsyncScheduler extends Scheduler {\r\n  public actions: Array<AsyncAction<any>> = [];\r\n  /**\r\n   * A flag to indicate whether the Scheduler is currently executing a batch of\r\n   * queued actions.\r\n   * @internal\r\n   */\r\n  public _active: boolean = false;\r\n  /**\r\n   * An internal ID used to track the latest asynchronous task such as those\r\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\r\n   * others.\r\n   * @internal\r\n   */\r\n  public _scheduled: TimerHandle | undefined;\r\n\r\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\r\n    super(SchedulerAction, now);\r\n  }\r\n\r\n  public flush(action: AsyncAction<any>): void {\r\n    const { actions } = this;\r\n\r\n    if (this._active) {\r\n      actions.push(action);\r\n      return;\r\n    }\r\n\r\n    let error: any;\r\n    this._active = true;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions.shift()!)) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AsapScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    const flushId = this._scheduled;\r\n    this._scheduled = undefined;\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AsapAction } from './AsapAction';\r\nimport { AsapScheduler } from './AsapScheduler';\r\n\r\n/**\r\n *\r\n * Asap Scheduler\r\n *\r\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\r\n *\r\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\r\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\r\n * code to end and then it will try to execute given task as fast as possible.\r\n *\r\n * `asap` scheduler will do its best to minimize time between end of currently executing code\r\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\r\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\r\n * some (although minimal) unwanted delay.\r\n *\r\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\r\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\r\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\r\n * as soon as possible, `asap` scheduler is your best bet.\r\n *\r\n * ## Example\r\n * Compare async and asap scheduler<\r\n * ```ts\r\n * import { asapScheduler, asyncScheduler } from 'rxjs';\r\n *\r\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\r\n * asapScheduler.schedule(() => console.log('asap'));\r\n *\r\n * // Logs:\r\n * // \"asap\"\r\n * // \"async\"\r\n * // ... but 'asap' goes first!\r\n * ```\r\n */\r\n\r\nexport const asapScheduler = new AsapScheduler(AsapAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\r\n */\r\nexport const asap = asapScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\n/**\r\n *\r\n * Async Scheduler\r\n *\r\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\r\n *\r\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\r\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\r\n * in intervals.\r\n *\r\n * If you just want to \"defer\" task, that is to perform it right after currently\r\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\r\n * better choice will be the {@link asapScheduler} scheduler.\r\n *\r\n * ## Examples\r\n * Use async scheduler to delay task\r\n * ```ts\r\n * import { asyncScheduler } from 'rxjs';\r\n *\r\n * const task = () => console.log('it works!');\r\n *\r\n * asyncScheduler.schedule(task, 2000);\r\n *\r\n * // After 2 seconds logs:\r\n * // \"it works!\"\r\n * ```\r\n *\r\n * Use async scheduler to repeat task in intervals\r\n * ```ts\r\n * import { asyncScheduler } from 'rxjs';\r\n *\r\n * function task(state) {\r\n *   console.log(state);\r\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\r\n *                                   // which we reschedule with new state and delay\r\n * }\r\n *\r\n * asyncScheduler.schedule(task, 3000, 0);\r\n *\r\n * // Logs:\r\n * // 0 after 3s\r\n * // 1 after 4s\r\n * // 2 after 5s\r\n * // 3 after 6s\r\n * ```\r\n */\r\n\r\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\r\n */\r\nexport const async = asyncScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { QueueScheduler } from './QueueScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class QueueAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (delay > 0) {\r\n      return super.schedule(state, delay);\r\n    }\r\n    this.delay = delay;\r\n    this.state = state;\r\n    this.scheduler.flush(this);\r\n    return this;\r\n  }\r\n\r\n  public execute(state: T, delay: number): any {\r\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n\r\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n\r\n    // Otherwise flush the scheduler starting with this action.\r\n    scheduler.flush(this);\r\n\r\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\r\n    // `TimerHandle`, and generally the return value here isn't really used. So the\r\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\r\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\r\n    return 0;\r\n  }\r\n}\r\n", "import { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class QueueScheduler extends AsyncScheduler {\r\n}\r\n", "import { QueueAction } from './QueueAction';\r\nimport { QueueScheduler } from './QueueScheduler';\r\n\r\n/**\r\n *\r\n * Queue Scheduler\r\n *\r\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\r\n *\r\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\r\n *\r\n * When used without delay, it schedules given task synchronously - executes it right when\r\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\r\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\r\n * that task will be put on a queue and wait for current one to finish.\r\n *\r\n * This means that when you execute task with `queue` scheduler, you are sure it will end\r\n * before any other task scheduled with that scheduler will start.\r\n *\r\n * ## Examples\r\n * Schedule recursively first, then do something\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(() => {\r\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\r\n *\r\n *   console.log('first');\r\n * });\r\n *\r\n * // Logs:\r\n * // \"first\"\r\n * // \"second\"\r\n * ```\r\n *\r\n * Reschedule itself recursively\r\n * ```ts\r\n * import { queueScheduler } from 'rxjs';\r\n *\r\n * queueScheduler.schedule(function(state) {\r\n *   if (state !== 0) {\r\n *     console.log('before', state);\r\n *     this.schedule(state - 1); // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n *     console.log('after', state);\r\n *   }\r\n * }, 0, 3);\r\n *\r\n * // In scheduler that runs recursively, you would expect:\r\n * // \"before\", 3\r\n * // \"before\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * // \"after\", 2\r\n * // \"after\", 3\r\n *\r\n * // But with queue it logs:\r\n * // \"before\", 3\r\n * // \"after\", 3\r\n * // \"before\", 2\r\n * // \"after\", 2\r\n * // \"before\", 1\r\n * // \"after\", 1\r\n * ```\r\n */\r\n\r\nexport const queueScheduler = new QueueScheduler(QueueAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\r\n */\r\nexport const queue = queueScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { animationFrameProvider } from './animationFrameProvider';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\r\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\r\n    super(scheduler, work);\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\r\n    // If delay is greater than 0, request as an async action.\r\n    if (delay !== null && delay > 0) {\r\n      return super.requestAsyncId(scheduler, id, delay);\r\n    }\r\n    // Push the action to the end of the scheduler queue.\r\n    scheduler.actions.push(this);\r\n    // If an animation frame has already been requested, don't request another\r\n    // one. If an animation frame hasn't been requested yet, request one. Return\r\n    // the current animation frame request id.\r\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\r\n    // If delay exists and is greater than 0, or if the delay is null (the\r\n    // action wasn't rescheduled) but was originally scheduled as an async\r\n    // action, then recycle as an async action.\r\n    if (delay != null ? delay > 0 : this.delay > 0) {\r\n      return super.recycleAsyncId(scheduler, id, delay);\r\n    }\r\n    // If the scheduler queue has no remaining actions with the same async id,\r\n    // cancel the requested animation frame and set the scheduled flag to\r\n    // undefined so the next AnimationFrameAction will request its own.\r\n    const { actions } = scheduler;\r\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\r\n      animationFrameProvider.cancelAnimationFrame(id as number);\r\n      scheduler._scheduled = undefined;\r\n    }\r\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\r\n    return undefined;\r\n  }\r\n}\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\n\r\nexport class AnimationFrameScheduler extends AsyncScheduler {\r\n  public flush(action?: AsyncAction<any>): void {\r\n    this._active = true;\r\n    // The async id that effects a call to flush is stored in _scheduled.\r\n    // Before executing an action, it's necessary to check the action's async\r\n    // id to determine whether it's supposed to be executed in the current\r\n    // flush.\r\n    // Previous implementations of this method used a count to determine this,\r\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\r\n    // are removed from the actions array and that can shift actions that are\r\n    // scheduled to be executed in a subsequent flush into positions at which\r\n    // they are executed within the current flush.\r\n    let flushId;\r\n    if (action) {\r\n      flushId = action.id;\r\n    } else {\r\n      flushId = this._scheduled;\r\n      this._scheduled = undefined;\r\n    }\r\n\r\n    const { actions } = this;\r\n    let error: any;\r\n    action = action || actions.shift()!;\r\n\r\n    do {\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\r\n\r\n    this._active = false;\r\n\r\n    if (error) {\r\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n", "import { AnimationFrameAction } from './AnimationFrameAction';\r\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\r\n\r\n/**\r\n *\r\n * Animation Frame Scheduler\r\n *\r\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\r\n *\r\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\r\n * behaviour.\r\n *\r\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\r\n * It makes sure scheduled task will happen just before next browser content repaint,\r\n * thus performing animations as efficiently as possible.\r\n *\r\n * ## Example\r\n * Schedule div height animation\r\n * ```ts\r\n * // html: <div style=\"background: #0ff;\"></div>\r\n * import { animationFrameScheduler } from 'rxjs';\r\n *\r\n * const div = document.querySelector('div');\r\n *\r\n * animationFrameScheduler.schedule(function(height) {\r\n *   div.style.height = height + \"px\";\r\n *\r\n *   this.schedule(height + 1);  // `this` references currently executing Action,\r\n *                               // which we reschedule with new state\r\n * }, 0, 0);\r\n *\r\n * // You will see a div element growing in height\r\n * ```\r\n */\r\n\r\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\r\n\r\n/**\r\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\r\n */\r\nexport const animationFrame = animationFrameScheduler;\r\n", "import { AsyncAction } from './AsyncAction';\r\nimport { Subscription } from '../Subscription';\r\nimport { AsyncScheduler } from './AsyncScheduler';\r\nimport { SchedulerAction } from '../types';\r\nimport { TimerHandle } from './timerHandle';\r\n\r\nexport class VirtualTimeScheduler extends AsyncScheduler {\r\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\r\n  static frameTimeFactor = 10;\r\n\r\n  /**\r\n   * The current frame for the state of the virtual scheduler instance. The difference\r\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\r\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\r\n   * that means `10` virtual time units have passed.\r\n   */\r\n  public frame: number = 0;\r\n\r\n  /**\r\n   * Used internally to examine the current virtual action index being processed.\r\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\r\n   */\r\n  public index: number = -1;\r\n\r\n  /**\r\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\r\n   * this constructor is likely to change in the long run.\r\n   *\r\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\r\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\r\n   */\r\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\r\n    super(schedulerActionCtor, () => this.frame);\r\n  }\r\n\r\n  /**\r\n   * Prompt the Scheduler to execute all of its queued actions, therefore\r\n   * clearing its queue.\r\n   */\r\n  public flush(): void {\r\n    const { actions, maxFrames } = this;\r\n    let error: any;\r\n    let action: AsyncAction<any> | undefined;\r\n\r\n    while ((action = actions[0]) && action.delay <= maxFrames) {\r\n      actions.shift();\r\n      this.frame = action.delay;\r\n\r\n      if ((error = action.execute(action.state, action.delay))) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (error) {\r\n      while ((action = actions.shift())) {\r\n        action.unsubscribe();\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport class VirtualAction<T> extends AsyncAction<T> {\r\n  protected active: boolean = true;\r\n\r\n  constructor(\r\n    protected scheduler: VirtualTimeScheduler,\r\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\r\n    protected index: number = (scheduler.index += 1)\r\n  ) {\r\n    super(scheduler, work);\r\n    this.index = scheduler.index = index;\r\n  }\r\n\r\n  public schedule(state?: T, delay: number = 0): Subscription {\r\n    if (Number.isFinite(delay)) {\r\n      if (!this.id) {\r\n        return super.schedule(state, delay);\r\n      }\r\n      this.active = false;\r\n      // If an action is rescheduled, we save allocations by mutating its state,\r\n      // pushing it to the end of the scheduler queue, and recycling the action.\r\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\r\n      // must be immutable so they can be inspected later.\r\n      const action = new VirtualAction(this.scheduler, this.work);\r\n      this.add(action);\r\n      return action.schedule(state, delay);\r\n    } else {\r\n      // If someone schedules something with Infinity, it'll never happen. So we\r\n      // don't even schedule it.\r\n      return Subscription.EMPTY;\r\n    }\r\n  }\r\n\r\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\r\n    this.delay = scheduler.frame + delay;\r\n    const { actions } = scheduler;\r\n    actions.push(this);\r\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\r\n    return 1;\r\n  }\r\n\r\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\r\n    return undefined;\r\n  }\r\n\r\n  protected _execute(state: T, delay: number): any {\r\n    if (this.active === true) {\r\n      return super._execute(state, delay);\r\n    }\r\n  }\r\n\r\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\r\n    if (a.delay === b.delay) {\r\n      if (a.index === b.index) {\r\n        return 0;\r\n      } else if (a.index > b.index) {\r\n        return 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    } else if (a.delay > b.delay) {\r\n      return 1;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\n\r\n/**\r\n * A simple Observable that emits no items to the Observer and immediately\r\n * emits a complete notification.\r\n *\r\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\r\n *\r\n * ![](empty.png)\r\n *\r\n * A simple Observable that only emits the complete notification. It can be used\r\n * for composing with other Observables, such as in a {@link mergeMap}.\r\n *\r\n * ## Examples\r\n *\r\n * Log complete notification\r\n *\r\n * ```ts\r\n * import { EMPTY } from 'rxjs';\r\n *\r\n * EMPTY.subscribe({\r\n *   next: () => console.log('Next'),\r\n *   complete: () => console.log('Complete!')\r\n * });\r\n *\r\n * // Outputs\r\n * // Complete!\r\n * ```\r\n *\r\n * Emit the number 7, then complete\r\n *\r\n * ```ts\r\n * import { EMPTY, startWith } from 'rxjs';\r\n *\r\n * const result = EMPTY.pipe(startWith(7));\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Outputs\r\n * // 7\r\n * ```\r\n *\r\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\r\n *\r\n * ```ts\r\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\r\n *\r\n * const interval$ = interval(1000);\r\n * const result = interval$.pipe(\r\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\r\n * );\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Results in the following to the console:\r\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\r\n * // x will occur every 1000ms\r\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\r\n * // if x % 2 is not equal to 1, nothing will be output\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link NEVER}\r\n * @see {@link of}\r\n * @see {@link throwError}\r\n */\r\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\r\n\r\n/**\r\n * @param scheduler A {@link SchedulerLike} to use for scheduling\r\n * the emission of the complete notification.\r\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\r\n */\r\nexport function empty(scheduler?: SchedulerLike) {\r\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\r\n}\r\n\r\nfunction emptyScheduled(scheduler: SchedulerLike) {\r\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { isFunction } from './isFunction';\r\n\r\nexport function isScheduler(value: any): value is SchedulerLike {\r\n  return value && isFunction(value.schedule);\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { isFunction } from './isFunction';\r\nimport { isScheduler } from './isScheduler';\r\n\r\nfunction last<T>(arr: T[]): T | undefined {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\r\n  return isFunction(last(args)) ? args.pop() : undefined;\r\n}\r\n\r\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\r\n  return isScheduler(last(args)) ? args.pop() : undefined;\r\n}\r\n\r\nexport function popNumber(args: any[], defaultValue: number): number {\r\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\r\n}\r\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\r\n\r\n/**\r\n * Tests to see if the object is \"thennable\".\r\n * @param value the object to test\r\n */\r\nexport function isPromise(value: any): value is PromiseLike<any> {\r\n  return isFunction(value?.then);\r\n}\r\n", "import { InteropObservable } from '../types';\r\nimport { observable as Symbol_observable } from '../symbol/observable';\r\nimport { isFunction } from './isFunction';\r\n\r\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\r\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\r\n  return isFunction(input[Symbol_observable]);\r\n}\r\n", "import { isFunction } from './isFunction';\r\n\r\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\r\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\r\n}\r\n", "/**\r\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\r\n * @param input The object that was passed.\r\n */\r\nexport function createInvalidObservableTypeError(input: any) {\r\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\r\n  return new TypeError(\r\n    `You provided ${\r\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\r\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\r\n  );\r\n}\r\n", "export function getSymbolIterator(): symbol {\r\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\r\n    return '@@iterator' as any;\r\n  }\r\n\r\n  return Symbol.iterator;\r\n}\r\n\r\nexport const iterator = getSymbolIterator();\r\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\r\nimport { isFunction } from './isFunction';\r\n\r\n/** Identifies an input as being an Iterable */\r\nexport function isIterable(input: any): input is Iterable<any> {\r\n  return isFunction(input?.[Symbol_iterator]);\r\n}\r\n", "import { ReadableStreamLike } from '../types';\r\nimport { isFunction } from './isFunction';\r\n\r\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\r\n  const reader = readableStream.getReader();\r\n  try {\r\n    while (true) {\r\n      const { value, done } = await reader.read();\r\n      if (done) {\r\n        return;\r\n      }\r\n      yield value!;\r\n    }\r\n  } finally {\r\n    reader.releaseLock();\r\n  }\r\n}\r\n\r\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\r\n  // We don't want to use instanceof checks because they would return\r\n  // false for instances from another Realm, like an <iframe>.\r\n  return isFunction(obj?.getReader);\r\n}\r\n", "import { isArrayLike } from '../util/isArrayLike';\r\nimport { isPromise } from '../util/isPromise';\r\nimport { Observable } from '../Observable';\r\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\r\nimport { isInteropObservable } from '../util/isInteropObservable';\r\nimport { isAsyncIterable } from '../util/isAsyncIterable';\r\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\r\nimport { isIterable } from '../util/isIterable';\r\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { reportUnhandledError } from '../util/reportUnhandledError';\r\nimport { observable as Symbol_observable } from '../symbol/observable';\r\n\r\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\r\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\r\n  if (input instanceof Observable) {\r\n    return input;\r\n  }\r\n  if (input != null) {\r\n    if (isInteropObservable(input)) {\r\n      return fromInteropObservable(input);\r\n    }\r\n    if (isArrayLike(input)) {\r\n      return fromArrayLike(input);\r\n    }\r\n    if (isPromise(input)) {\r\n      return fromPromise(input);\r\n    }\r\n    if (isAsyncIterable(input)) {\r\n      return fromAsyncIterable(input);\r\n    }\r\n    if (isIterable(input)) {\r\n      return fromIterable(input);\r\n    }\r\n    if (isReadableStreamLike(input)) {\r\n      return fromReadableStreamLike(input);\r\n    }\r\n  }\r\n\r\n  throw createInvalidObservableTypeError(input);\r\n}\r\n\r\n/**\r\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\r\n * @param obj An object that properly implements `Symbol.observable`.\r\n */\r\nexport function fromInteropObservable<T>(obj: any) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    const obs = obj[Symbol_observable]();\r\n    if (isFunction(obs.subscribe)) {\r\n      return obs.subscribe(subscriber);\r\n    }\r\n    // Should be caught by observable subscribe function error handling.\r\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\r\n  });\r\n}\r\n\r\n/**\r\n * Synchronously emits the values of an array like and completes.\r\n * This is exported because there are creation functions and operators that need to\r\n * make direct use of the same logic, and there's no reason to make them run through\r\n * `from` conditionals because we *know* they're dealing with an array.\r\n * @param array The array to emit values from\r\n */\r\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    // Loop over the array and emit each value. Note two things here:\r\n    // 1. We're making sure that the subscriber is not closed on each loop.\r\n    //    This is so we don't continue looping over a very large array after\r\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\r\n    //    has already unsubscribed.\r\n    // 2. In this form, reentrant code can alter that array we're looping over.\r\n    //    This is a known issue, but considered an edge case. The alternative would\r\n    //    be to copy the array before executing the loop, but this has\r\n    //    performance implications.\r\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\r\n      subscriber.next(array[i]);\r\n    }\r\n    subscriber.complete();\r\n  });\r\n}\r\n\r\nexport function fromPromise<T>(promise: PromiseLike<T>) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    promise\r\n      .then(\r\n        (value) => {\r\n          if (!subscriber.closed) {\r\n            subscriber.next(value);\r\n            subscriber.complete();\r\n          }\r\n        },\r\n        (err: any) => subscriber.error(err)\r\n      )\r\n      .then(null, reportUnhandledError);\r\n  });\r\n}\r\n\r\nexport function fromIterable<T>(iterable: Iterable<T>) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    for (const value of iterable) {\r\n      subscriber.next(value);\r\n      if (subscriber.closed) {\r\n        return;\r\n      }\r\n    }\r\n    subscriber.complete();\r\n  });\r\n}\r\n\r\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\r\n  return new Observable((subscriber: Subscriber<T>) => {\r\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\r\n  });\r\n}\r\n\r\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\r\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\r\n}\r\n\r\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\r\n  for await (const value of asyncIterable) {\r\n    subscriber.next(value);\r\n    // A side-effect may have closed our subscriber,\r\n    // check before the next iteration.\r\n    if (subscriber.closed) {\r\n      return;\r\n    }\r\n  }\r\n  subscriber.complete();\r\n}\r\n", "import { Subscription } from '../Subscription';\r\nimport { SchedulerAction, SchedulerLike } from '../types';\r\n\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay: number,\r\n  repeat: true\r\n): void;\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay?: number,\r\n  repeat?: false\r\n): Subscription;\r\n\r\nexport function executeSchedule(\r\n  parentSubscription: Subscription,\r\n  scheduler: SchedulerLike,\r\n  work: () => void,\r\n  delay = 0,\r\n  repeat = false\r\n): Subscription | void {\r\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\r\n    work();\r\n    if (repeat) {\r\n      parentSubscription.add(this.schedule(null, delay));\r\n    } else {\r\n      this.unsubscribe();\r\n    }\r\n  }, delay);\r\n\r\n  parentSubscription.add(scheduleSubscription);\r\n\r\n  if (!repeat) {\r\n    // Because user-land scheduler implementations are unlikely to properly reuse\r\n    // Actions for repeat scheduling, we can't trust that the returned subscription\r\n    // will control repeat subscription scenarios. So we're trying to avoid using them\r\n    // incorrectly within this library.\r\n    return scheduleSubscription;\r\n  }\r\n}\r\n", "/** @prettier */\r\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Re-emits all notifications from source Observable with specified scheduler.\r\n *\r\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\r\n *\r\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\r\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\r\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\r\n *\r\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\r\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\r\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\r\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\r\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\r\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\r\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\r\n * little bit more, to ensure that they are emitted at expected moments.\r\n *\r\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\r\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\r\n * will delay all notifications - including error notifications - while `delay` will pass through error\r\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\r\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\r\n * for notification emissions in general.\r\n *\r\n * ## Example\r\n *\r\n * Ensure values in subscribe are called just before browser repaint\r\n *\r\n * ```ts\r\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\r\n *\r\n * const someDiv = document.createElement('div');\r\n * someDiv.style.cssText = 'width: 200px;background: #09c';\r\n * document.body.appendChild(someDiv);\r\n * const intervals = interval(10);      // Intervals are scheduled\r\n *                                      // with async scheduler by default...\r\n * intervals.pipe(\r\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\r\n * )                                    // scheduler to ensure smooth animation.\r\n * .subscribe(val => {\r\n *   someDiv.style.height = val + 'px';\r\n * });\r\n * ```\r\n *\r\n * @see {@link delay}\r\n *\r\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\r\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\r\n * @return A function that returns an Observable that emits the same\r\n * notifications as the source Observable, but with provided scheduler.\r\n */\r\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\r\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\r\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\n\r\n/**\r\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\r\n *\r\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\r\n *\r\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\r\n *\r\n * ![](subscribeOn.png)\r\n *\r\n * ## Example\r\n *\r\n * Given the following code:\r\n *\r\n * ```ts\r\n * import { of, merge } from 'rxjs';\r\n *\r\n * const a = of(1, 2, 3);\r\n * const b = of(4, 5, 6);\r\n *\r\n * merge(a, b).subscribe(console.log);\r\n *\r\n * // Outputs\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * // 5\r\n * // 6\r\n * ```\r\n *\r\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\r\n *\r\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\r\n *\r\n * ```ts\r\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\r\n *\r\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\r\n * const b = of(4, 5, 6);\r\n *\r\n * merge(a, b).subscribe(console.log);\r\n *\r\n * // Outputs\r\n * // 4\r\n * // 5\r\n * // 6\r\n * // 1\r\n * // 2\r\n * // 3\r\n * ```\r\n *\r\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\r\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\r\n *\r\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\r\n * @param delay A delay to pass to the scheduler to delay subscriptions\r\n * @return A function that returns an Observable modified so that its\r\n * subscriptions happen on the specified {@link SchedulerLike}.\r\n */\r\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\r\n  });\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { InteropObservable, SchedulerLike } from '../types';\r\n\r\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\r\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\r\n}\r\n", "import { innerFrom } from '../observable/innerFrom';\r\nimport { observeOn } from '../operators/observeOn';\r\nimport { subscribeOn } from '../operators/subscribeOn';\r\nimport { SchedulerLike } from '../types';\r\n\r\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\r\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\n\r\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\r\n  return new Observable<T>((subscriber) => {\r\n    // The current array index.\r\n    let i = 0;\r\n    // Start iterating over the array like on a schedule.\r\n    return scheduler.schedule(function () {\r\n      if (i === input.length) {\r\n        // If we have hit the end of the array like in the\r\n        // previous job, we can complete.\r\n        subscriber.complete();\r\n      } else {\r\n        // Otherwise let's next the value at the current index,\r\n        // then increment our index.\r\n        subscriber.next(input[i++]);\r\n        // If the last emission didn't cause us to close the subscriber\r\n        // (via take or some side effect), reschedule the job and we'll\r\n        // make another pass.\r\n        if (!subscriber.closed) {\r\n          this.schedule();\r\n        }\r\n      }\r\n    });\r\n  });\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { SchedulerLike } from '../types';\r\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\r\nimport { isFunction } from '../util/isFunction';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\n/**\r\n * Used in {@link scheduled} to create an observable from an Iterable.\r\n * @param input The iterable to create an observable from\r\n * @param scheduler The scheduler to use\r\n */\r\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\r\n  return new Observable<T>((subscriber) => {\r\n    let iterator: Iterator<T, T>;\r\n\r\n    // Schedule the initial creation of the iterator from\r\n    // the iterable. This is so the code in the iterable is\r\n    // not called until the scheduled job fires.\r\n    executeSchedule(subscriber, scheduler, () => {\r\n      // Create the iterator.\r\n      iterator = (input as any)[Symbol_iterator]();\r\n\r\n      executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          let value: T;\r\n          let done: boolean | undefined;\r\n          try {\r\n            // Pull the value out of the iterator\r\n            ({ value, done } = iterator.next());\r\n          } catch (err) {\r\n            // We got an error while pulling from the iterator\r\n            subscriber.error(err);\r\n            return;\r\n          }\r\n\r\n          if (done) {\r\n            // If it is \"done\" we just complete. This mimics the\r\n            // behavior of JavaScript's `for..of` consumption of\r\n            // iterables, which will not emit the value from an iterator\r\n            // result of `{ done: true: value: 'here' }`.\r\n            subscriber.complete();\r\n          } else {\r\n            // The iterable is not done, emit the value.\r\n            subscriber.next(value);\r\n          }\r\n        },\r\n        0,\r\n        true\r\n      );\r\n    });\r\n\r\n    // During finalization, if we see this iterator has a `return` method,\r\n    // then we know it is a Generator, and not just an Iterator. So we call\r\n    // the `return()` function. This will ensure that any `finally { }` blocks\r\n    // inside of the generator we can hit will be hit properly.\r\n    return () => isFunction(iterator?.return) && iterator.return();\r\n  });\r\n}\r\n", "import { SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\r\n  if (!input) {\r\n    throw new Error('Iterable cannot be null');\r\n  }\r\n  return new Observable<T>((subscriber) => {\r\n    executeSchedule(subscriber, scheduler, () => {\r\n      const iterator = input[Symbol.asyncIterator]();\r\n      executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          iterator.next().then((result) => {\r\n            if (result.done) {\r\n              // This will remove the subscriptions from\r\n              // the parent subscription.\r\n              subscriber.complete();\r\n            } else {\r\n              subscriber.next(result.value);\r\n            }\r\n          });\r\n        },\r\n        0,\r\n        true\r\n      );\r\n    });\r\n  });\r\n}\r\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\r\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\r\n\r\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\r\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\r\n}\r\n", "import { scheduleObservable } from './scheduleObservable';\r\nimport { schedulePromise } from './schedulePromise';\r\nimport { scheduleArray } from './scheduleArray';\r\nimport { scheduleIterable } from './scheduleIterable';\r\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\r\nimport { isInteropObservable } from '../util/isInteropObservable';\r\nimport { isPromise } from '../util/isPromise';\r\nimport { isArrayLike } from '../util/isArrayLike';\r\nimport { isIterable } from '../util/isIterable';\r\nimport { ObservableInput, SchedulerLike } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { isAsyncIterable } from '../util/isAsyncIterable';\r\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\r\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\r\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\r\n\r\n/**\r\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\r\n * are scheduled on the provided scheduler.\r\n *\r\n * @see {@link from}\r\n * @see {@link of}\r\n *\r\n * @param input The observable, array, promise, iterable, etc you would like to schedule\r\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\r\n * the returned observable.\r\n */\r\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\r\n  if (input != null) {\r\n    if (isInteropObservable(input)) {\r\n      return scheduleObservable(input, scheduler);\r\n    }\r\n    if (isArrayLike(input)) {\r\n      return scheduleArray(input, scheduler);\r\n    }\r\n    if (isPromise(input)) {\r\n      return schedulePromise(input, scheduler);\r\n    }\r\n    if (isAsyncIterable(input)) {\r\n      return scheduleAsyncIterable(input, scheduler);\r\n    }\r\n    if (isIterable(input)) {\r\n      return scheduleIterable(input, scheduler);\r\n    }\r\n    if (isReadableStreamLike(input)) {\r\n      return scheduleReadableStreamLike(input, scheduler);\r\n    }\r\n  }\r\n  throw createInvalidObservableTypeError(input);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\r\nimport { scheduled } from '../scheduled/scheduled';\r\nimport { innerFrom } from './innerFrom';\r\n\r\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\r\n\r\n/**\r\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\r\n *\r\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\r\n *\r\n * ![](from.png)\r\n *\r\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\r\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\r\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\r\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\r\n * converted through this operator.\r\n *\r\n * ## Examples\r\n *\r\n * Converts an array to an Observable\r\n *\r\n * ```ts\r\n * import { from } from 'rxjs';\r\n *\r\n * const array = [10, 20, 30];\r\n * const result = from(array);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 10\r\n * // 20\r\n * // 30\r\n * ```\r\n *\r\n * Convert an infinite iterable (from a generator) to an Observable\r\n *\r\n * ```ts\r\n * import { from, take } from 'rxjs';\r\n *\r\n * function* generateDoubles(seed) {\r\n *    let i = seed;\r\n *    while (true) {\r\n *      yield i;\r\n *      i = 2 * i; // double it\r\n *    }\r\n * }\r\n *\r\n * const iterator = generateDoubles(3);\r\n * const result = from(iterator).pipe(take(10));\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 3\r\n * // 6\r\n * // 12\r\n * // 24\r\n * // 48\r\n * // 96\r\n * // 192\r\n * // 384\r\n * // 768\r\n * // 1536\r\n * ```\r\n *\r\n * With `asyncScheduler`\r\n *\r\n * ```ts\r\n * import { from, asyncScheduler } from 'rxjs';\r\n *\r\n * console.log('start');\r\n *\r\n * const array = [10, 20, 30];\r\n * const result = from(array, asyncScheduler);\r\n *\r\n * result.subscribe(x => console.log(x));\r\n *\r\n * console.log('end');\r\n *\r\n * // Logs:\r\n * // 'start'\r\n * // 'end'\r\n * // 10\r\n * // 20\r\n * // 30\r\n * ```\r\n *\r\n * @see {@link fromEvent}\r\n * @see {@link fromEventPattern}\r\n *\r\n * @param input A subscription object, a Promise, an Observable-like,\r\n * an Array, an iterable, or an array-like object to be converted.\r\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\r\n * @return An Observable converted from {@link ObservableInput}.\r\n */\r\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\r\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\r\n}\r\n", "import { SchedulerLike, ValueFromArray } from '../types';\r\nimport { Observable } from '../Observable';\r\nimport { popScheduler } from '../util/args';\r\nimport { from } from './from';\r\n\r\n// Devs are more likely to pass null or undefined than they are a scheduler\r\n// without accompanying values. To make things easier for (naughty) devs who\r\n// use the `strictNullChecks: false` TypeScript compiler option, these\r\n// overloads with explicit null and undefined values are included.\r\n\r\nexport function of(value: null): Observable<null>;\r\nexport function of(value: undefined): Observable<undefined>;\r\n\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of(scheduler: SchedulerLike): Observable<never>;\r\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\r\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\r\n\r\nexport function of(): Observable<never>;\r\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\r\nexport function of<T>(): Observable<T>;\r\nexport function of<T>(value: T): Observable<T>;\r\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\r\n\r\n/**\r\n * Converts the arguments to an observable sequence.\r\n *\r\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\r\n *\r\n * ![](of.png)\r\n *\r\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\r\n * as a separate `next` notification.\r\n *\r\n * ## Examples\r\n *\r\n * Emit the values `10, 20, 30`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of(10, 20, 30)\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: 10\r\n * // next: 20\r\n * // next: 30\r\n * // the end\r\n * ```\r\n *\r\n * Emit the array `[1, 2, 3]`\r\n *\r\n * ```ts\r\n * import { of } from 'rxjs';\r\n *\r\n * of([1, 2, 3])\r\n *   .subscribe({\r\n *     next: value => console.log('next:', value),\r\n *     error: err => console.log('error:', err),\r\n *     complete: () => console.log('the end'),\r\n *   });\r\n *\r\n * // Outputs\r\n * // next: [1, 2, 3]\r\n * // the end\r\n * ```\r\n *\r\n * @see {@link from}\r\n * @see {@link range}\r\n *\r\n * @param args A comma separated list of arguments you want to be emitted.\r\n * @return An Observable that synchronously emits the arguments described\r\n * above and then immediately completes.\r\n */\r\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\r\n  const scheduler = popScheduler(args);\r\n  return from(args as T[], scheduler);\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { SchedulerLike } from '../types';\r\nimport { isFunction } from '../util/isFunction';\r\n\r\n/**\r\n * Creates an observable that will create an error instance and push it to the consumer as an error\r\n * immediately upon subscription.\r\n *\r\n * <span class=\"informal\">Just errors and does nothing else</span>\r\n *\r\n * ![](throw.png)\r\n *\r\n * This creation function is useful for creating an observable that will create an error and error every\r\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\r\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\r\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\r\n * that up and notify the consumer of the error.\r\n *\r\n * ## Example\r\n *\r\n * Create a simple observable that will create a new error with a timestamp and log it\r\n * and the message every time you subscribe to it\r\n *\r\n * ```ts\r\n * import { throwError } from 'rxjs';\r\n *\r\n * let errorCount = 0;\r\n *\r\n * const errorWithTimestamp$ = throwError(() => {\r\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\r\n *   error.timestamp = Date.now();\r\n *   return error;\r\n * });\r\n *\r\n * errorWithTimestamp$.subscribe({\r\n *   error: err => console.log(err.timestamp, err.message)\r\n * });\r\n *\r\n * errorWithTimestamp$.subscribe({\r\n *   error: err => console.log(err.timestamp, err.message)\r\n * });\r\n *\r\n * // Logs the timestamp and a new error message for each subscription\r\n * ```\r\n *\r\n * ### Unnecessary usage\r\n *\r\n * Using `throwError` inside of an operator or creation function\r\n * with a callback, is usually not necessary\r\n *\r\n * ```ts\r\n * import { of, concatMap, timer, throwError } from 'rxjs';\r\n *\r\n * const delays$ = of(1000, 2000, Infinity, 3000);\r\n *\r\n * delays$.pipe(\r\n *   concatMap(ms => {\r\n *     if (ms < 10000) {\r\n *       return timer(ms);\r\n *     } else {\r\n *       // This is probably overkill.\r\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\r\n *     }\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * You can just throw the error instead\r\n *\r\n * ```ts\r\n * import { of, concatMap, timer } from 'rxjs';\r\n *\r\n * const delays$ = of(1000, 2000, Infinity, 3000);\r\n *\r\n * delays$.pipe(\r\n *   concatMap(ms => {\r\n *     if (ms < 10000) {\r\n *       return timer(ms);\r\n *     } else {\r\n *       // Cleaner and easier to read for most folks.\r\n *       throw new Error(`Invalid time ${ ms }`);\r\n *     }\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * @param errorFactory A factory function that will create the error instance that is pushed.\r\n */\r\nexport function throwError(errorFactory: () => any): Observable<never>;\r\n\r\n/**\r\n * Returns an observable that will error with the specified error immediately upon subscription.\r\n *\r\n * @param error The error instance to emit\r\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\r\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\r\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\r\n */\r\nexport function throwError(error: any): Observable<never>;\r\n\r\n/**\r\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\r\n *\r\n * @param errorOrErrorFactory An error instance or error factory\r\n * @param scheduler A scheduler to use to schedule the error notification\r\n * @deprecated The `scheduler` parameter will be removed in v8.\r\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\r\n * Details: https://rxjs.dev/deprecations/scheduler-argument\r\n */\r\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\r\n\r\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\r\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\r\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\r\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\r\n}\r\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\r\nimport { Observable } from './Observable';\r\nimport { EMPTY } from './observable/empty';\r\nimport { of } from './observable/of';\r\nimport { throwError } from './observable/throwError';\r\nimport { isFunction } from './util/isFunction';\r\n\r\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\r\n/**\r\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\r\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\r\n */\r\nexport enum NotificationKind {\r\n  NEXT = 'N',\r\n  ERROR = 'E',\r\n  COMPLETE = 'C',\r\n}\r\n\r\n/**\r\n * Represents a push-based event or value that an {@link Observable} can emit.\r\n * This class is particularly useful for operators that manage notifications,\r\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\r\n * others. Besides wrapping the actual delivered value, it also annotates it\r\n * with metadata of, for instance, what type of push message it is (`next`,\r\n * `error`, or `complete`).\r\n *\r\n * @see {@link materialize}\r\n * @see {@link dematerialize}\r\n * @see {@link observeOn}\r\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n * Will be removed in v8.\r\n */\r\nexport class Notification<T> {\r\n  /**\r\n   * A value signifying that the notification will \"next\" if observed. In truth,\r\n   * This is really synonymous with just checking `kind === \"N\"`.\r\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\r\n   */\r\n  readonly hasValue: boolean;\r\n\r\n  /**\r\n   * Creates a \"Next\" notification object.\r\n   * @param kind Always `'N'`\r\n   * @param value The value to notify with if observed.\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\r\n   */\r\n  constructor(kind: 'N', value?: T);\r\n  /**\r\n   * Creates an \"Error\" notification object.\r\n   * @param kind Always `'E'`\r\n   * @param value Always `undefined`\r\n   * @param error The error to notify with if observed.\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\r\n   */\r\n  constructor(kind: 'E', value: undefined, error: any);\r\n  /**\r\n   * Creates a \"completion\" notification object.\r\n   * @param kind Always `'C'`\r\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\r\n   */\r\n  constructor(kind: 'C');\r\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\r\n    this.hasValue = kind === 'N';\r\n  }\r\n\r\n  /**\r\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n   * @param observer The observer to notify.\r\n   */\r\n  observe(observer: PartialObserver<T>): void {\r\n    return observeNotification(this as ObservableNotification<T>, observer);\r\n  }\r\n\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @param complete A complete handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void, error: (err: any) => void): void;\r\n  /**\r\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\r\n   * this will not error, and it will be a noop.\r\n   * @param next The next handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  do(next: (value: T) => void): void;\r\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\r\n    const { kind, value, error } = this;\r\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\r\n  }\r\n\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @param complete A complete handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\r\n  /**\r\n   * Executes a notification on the appropriate handler from a list provided.\r\n   * If a handler is missing for the kind of notification, nothing is called\r\n   * and no error is thrown, it will be a noop.\r\n   * @param next A next handler\r\n   * @param error An error handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void, error: (err: any) => void): void;\r\n  /**\r\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\r\n   * this will not error, and it will be a noop.\r\n   * @param next The next handler\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(next: (value: T) => void): void;\r\n\r\n  /**\r\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n   * @param observer The observer to notify.\r\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\r\n   */\r\n  accept(observer: PartialObserver<T>): void;\r\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\r\n    return isFunction((nextOrObserver as any)?.next)\r\n      ? this.observe(nextOrObserver as PartialObserver<T>)\r\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\r\n  }\r\n\r\n  /**\r\n   * Returns a simple Observable that just delivers the notification represented\r\n   * by this Notification instance.\r\n   *\r\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\r\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\r\n   */\r\n  toObservable(): Observable<T> {\r\n    const { kind, value, error } = this;\r\n    // Select the observable to return by `kind`\r\n    const result =\r\n      kind === 'N'\r\n        ? // Next kind. Return an observable of that value.\r\n          of(value!)\r\n        : //\r\n        kind === 'E'\r\n        ? // Error kind. Return an observable that emits the error.\r\n          throwError(() => error)\r\n        : //\r\n        kind === 'C'\r\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\r\n          EMPTY\r\n        : // Unknown kind, return falsy, so we error below.\r\n          0;\r\n    if (!result) {\r\n      // TODO: consider removing this check. The only way to cause this would be to\r\n      // use the Notification constructor directly in a way that is not type-safe.\r\n      // and direct use of the Notification constructor is deprecated.\r\n      throw new TypeError(`Unexpected notification kind ${kind}`);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `next` from a\r\n   * given value.\r\n   * @param value The `next` value.\r\n   * @return The \"next\" Notification representing the argument.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createNext<T>(value: T) {\r\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\r\n  }\r\n\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `error` from a\r\n   * given error.\r\n   * @param err The `error` error.\r\n   * @return The \"error\" Notification representing the argument.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createError(err?: any) {\r\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\r\n  }\r\n\r\n  /**\r\n   * A shortcut to create a Notification instance of the type `complete`.\r\n   * @return The valueless \"complete\" Notification.\r\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\r\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\r\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\r\n   * Will be removed in v8.\r\n   */\r\n  static createComplete(): Notification<never> & CompleteNotification {\r\n    return Notification.completeNotification;\r\n  }\r\n}\r\n\r\n/**\r\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\r\n * If the handler is missing it will do nothing. Even if the notification is an error, if\r\n * there is no error handler on the observer, an error will not be thrown, it will noop.\r\n * @param notification The notification object to observe.\r\n * @param observer The observer to notify.\r\n */\r\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\r\n  const { kind, value, error } = notification as any;\r\n  if (typeof kind !== 'string') {\r\n    throw new TypeError('Invalid notification, missing \"kind\"');\r\n  }\r\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\r\n}\r\n", "/** prettier */\r\nimport { Observable } from '../Observable';\r\nimport { isFunction } from './isFunction';\r\n\r\n/**\r\n * Tests to see if the object is an RxJS {@link Observable}\r\n * @param obj the object to test\r\n */\r\nexport function isObservable(obj: any): obj is Observable<unknown> {\r\n  // The !! is to ensure that this publicly exposed function returns\r\n  // `false` if something like `null` or `0` is passed.\r\n  return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\r\n}\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface EmptyError extends Error {}\r\n\r\nexport interface EmptyErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): EmptyError;\r\n}\r\n\r\n/**\r\n * An error thrown when an Observable or a sequence was queried but has no\r\n * elements.\r\n *\r\n * @see {@link first}\r\n * @see {@link last}\r\n * @see {@link single}\r\n * @see {@link firstValueFrom}\r\n * @see {@link lastValueFrom}\r\n */\r\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function EmptyErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'EmptyError';\r\n      this.message = 'no elements in sequence';\r\n    }\r\n);\r\n", "import { Observable } from './Observable';\r\nimport { EmptyError } from './util/EmptyError';\r\nimport { SafeSubscriber } from './Subscriber';\r\n\r\nexport interface FirstValueFromConfig<T> {\r\n  defaultValue: T;\r\n}\r\n\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\r\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\r\n\r\n/**\r\n * Converts an observable to a promise by subscribing to the observable,\r\n * and returning a promise that will resolve as soon as the first value\r\n * arrives from the observable. The subscription will then be closed.\r\n *\r\n * If the observable stream completes before any values were emitted, the\r\n * returned promise will reject with {@link EmptyError} or will resolve\r\n * with the default value if a default was specified.\r\n *\r\n * If the observable stream emits an error, the returned promise will reject\r\n * with that error.\r\n *\r\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\r\n * *OR* complete. If the source observable does not emit one value or complete, you will\r\n * end up with a promise that is hung up, and potentially all of the state of an\r\n * async function hanging out in memory. To avoid this situation, look into adding\r\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\r\n * amongst others.\r\n *\r\n * ## Example\r\n *\r\n * Wait for the first value from a stream and emit it from a promise in\r\n * an async function\r\n *\r\n * ```ts\r\n * import { interval, firstValueFrom } from 'rxjs';\r\n *\r\n * async function execute() {\r\n *   const source$ = interval(2000);\r\n *   const firstNumber = await firstValueFrom(source$);\r\n *   console.log(`The first number is ${ firstNumber }`);\r\n * }\r\n *\r\n * execute();\r\n *\r\n * // Expected output:\r\n * // 'The first number is 0'\r\n * ```\r\n *\r\n * @see {@link lastValueFrom}\r\n *\r\n * @param source the observable to convert to a promise\r\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\r\n */\r\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\r\n  const hasConfig = typeof config === 'object';\r\n  return new Promise<T | D>((resolve, reject) => {\r\n    const subscriber = new SafeSubscriber<T>({\r\n      next: (value) => {\r\n        resolve(value);\r\n        subscriber.unsubscribe();\r\n      },\r\n      error: reject,\r\n      complete: () => {\r\n        if (hasConfig) {\r\n          resolve(config!.defaultValue);\r\n        } else {\r\n          reject(new EmptyError());\r\n        }\r\n      },\r\n    });\r\n    source.subscribe(subscriber);\r\n  });\r\n}\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface ArgumentOutOfRangeError extends Error {}\r\n\r\nexport interface ArgumentOutOfRangeErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (): ArgumentOutOfRangeError;\r\n}\r\n\r\n/**\r\n * An error thrown when an element was queried at a certain index of an\r\n * Observable, but no such index or position exists in that sequence.\r\n *\r\n * @see {@link elementAt}\r\n * @see {@link take}\r\n * @see {@link takeLast}\r\n */\r\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function ArgumentOutOfRangeErrorImpl(this: any) {\r\n      _super(this);\r\n      this.name = 'ArgumentOutOfRangeError';\r\n      this.message = 'argument out of range';\r\n    }\r\n);\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface NotFoundError extends Error {}\r\n\r\nexport interface NotFoundErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (message: string): NotFoundError;\r\n}\r\n\r\n/**\r\n * An error thrown when a value or values are missing from an\r\n * observable sequence.\r\n *\r\n * @see {@link operators/single}\r\n */\r\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function NotFoundErrorImpl(this: any, message: string) {\r\n      _super(this);\r\n      this.name = 'NotFoundError';\r\n      this.message = message;\r\n    }\r\n);\r\n", "import { createErrorClass } from './createErrorClass';\r\n\r\nexport interface SequenceError extends Error {}\r\n\r\nexport interface SequenceErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new (message: string): SequenceError;\r\n}\r\n\r\n/**\r\n * An error thrown when something is wrong with the sequence of\r\n * values arriving on the observable.\r\n *\r\n * @see {@link operators/single}\r\n */\r\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function SequenceErrorImpl(this: any, message: string) {\r\n      _super(this);\r\n      this.name = 'SequenceError';\r\n      this.message = message;\r\n    }\r\n);\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\r\nimport { isValidDate } from '../util/isDate';\r\nimport { Subscription } from '../Subscription';\r\nimport { operate } from '../util/lift';\r\nimport { Observable } from '../Observable';\r\nimport { innerFrom } from '../observable/innerFrom';\r\nimport { createErrorClass } from '../util/createErrorClass';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\nimport { executeSchedule } from '../util/executeSchedule';\r\n\r\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\r\n  /**\r\n   * The time allowed between values from the source before timeout is triggered.\r\n   */\r\n  each?: number;\r\n\r\n  /**\r\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\r\n   * by which the first value must arrive from the source before timeout is triggered.\r\n   */\r\n  first?: number | Date;\r\n\r\n  /**\r\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\r\n   */\r\n  scheduler?: SchedulerLike;\r\n\r\n  /**\r\n   * A factory used to create observable to switch to when timeout occurs. Provides\r\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\r\n   * exact time triggered the timeout.\r\n   */\r\n  with?: (info: TimeoutInfo<T, M>) => O;\r\n\r\n  /**\r\n   * Optional additional metadata you can provide to code that handles\r\n   * the timeout, will be provided through the {@link TimeoutError}.\r\n   * This can be used to help identify the source of a timeout or pass along\r\n   * other information related to the timeout.\r\n   */\r\n  meta?: M;\r\n}\r\n\r\nexport interface TimeoutInfo<T, M = unknown> {\r\n  /** Optional metadata that was provided to the timeout configuration. */\r\n  readonly meta: M;\r\n  /** The number of messages seen before the timeout */\r\n  readonly seen: number;\r\n  /** The last message seen */\r\n  readonly lastValue: T | null;\r\n}\r\n\r\n/**\r\n * An error emitted when a timeout occurs.\r\n */\r\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\r\n  /**\r\n   * The information provided to the error by the timeout\r\n   * operation that created the error. Will be `null` if\r\n   * used directly in non-RxJS code with an empty constructor.\r\n   * (Note that using this constructor directly is not recommended,\r\n   * you should create your own errors)\r\n   */\r\n  info: TimeoutInfo<T, M> | null;\r\n}\r\n\r\nexport interface TimeoutErrorCtor {\r\n  /**\r\n   * @deprecated Internal implementation detail. Do not construct error instances.\r\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\r\n   */\r\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\r\n}\r\n\r\n/**\r\n * An error thrown by the {@link timeout} operator.\r\n *\r\n * Provided so users can use as a type and do quality comparisons.\r\n * We recommend you do not subclass this or create instances of this class directly.\r\n * If you have need of a error representing a timeout, you should\r\n * create your own error class and use that.\r\n *\r\n * @see {@link timeout}\r\n */\r\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\r\n  (_super) =>\r\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\r\n      _super(this);\r\n      this.message = 'Timeout has occurred';\r\n      this.name = 'TimeoutError';\r\n      this.info = info;\r\n    }\r\n);\r\n\r\n/**\r\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\r\n * does not push values within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a custom error if there is too much time between values\r\n *\r\n * ```ts\r\n * import { interval, timeout, throwError } from 'rxjs';\r\n *\r\n * class CustomTimeoutError extends Error {\r\n *   constructor() {\r\n *     super('It was too slow');\r\n *     this.name = 'CustomTimeoutError';\r\n *   }\r\n * }\r\n *\r\n * const slow$ = interval(900);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => throwError(() => new CustomTimeoutError())\r\n *   })\r\n * )\r\n * .subscribe({\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Switch to a faster observable if your source is slow.\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * const slow$ = interval(900);\r\n * const fast$ = interval(500);\r\n *\r\n * slow$.pipe(\r\n *   timeout({\r\n *     each: 1000,\r\n *     with: () => fast$,\r\n *   })\r\n * )\r\n * .subscribe(console.log);\r\n * ```\r\n * @param config The configuration for the timeout.\r\n */\r\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\r\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\r\n): OperatorFunction<T, T | ObservedValueOf<O>>;\r\n\r\n/**\r\n * Returns an observable that will error or switch to a different observable if the source does not push values\r\n * within the specified time parameters.\r\n *\r\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\r\n *\r\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\r\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\r\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\r\n * the settings in `first` and `each`.\r\n *\r\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\r\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\r\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\r\n * against the time period provided by `each`, if it was provided.\r\n *\r\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\r\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\r\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\r\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\r\n *\r\n * ### Handling TimeoutErrors\r\n *\r\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\r\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\r\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\r\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\r\n *\r\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\r\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\r\n *\r\n * ## Examples\r\n *\r\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\r\n *\r\n * ```ts\r\n * import { interval, timeout } from 'rxjs';\r\n *\r\n * // A random interval that lasts between 0 and 10 seconds per tick\r\n * const source$ = interval(Math.round(Math.random() * 10_000));\r\n *\r\n * source$.pipe(\r\n *   timeout({ first: 5_000 })\r\n * )\r\n * .subscribe({\r\n *   next: console.log,\r\n *   error: console.error\r\n * });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\r\n * and subscription.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n *\r\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\r\n * 5 seconds between any two values after the first.\r\n *\r\n * ```ts\r\n * import { timer, timeout, expand } from 'rxjs';\r\n *\r\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\r\n *\r\n * // An observable that waits a random amount of time between each delivered value\r\n * const source$ = timer(getRandomTime())\r\n *   .pipe(expand(() => timer(getRandomTime())));\r\n *\r\n * source$\r\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\r\n *   .subscribe({\r\n *     next: console.log,\r\n *     error: console.error\r\n *   });\r\n * ```\r\n */\r\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\r\n * This is functionally the same as `timeout({ first: someDate })`.\r\n *\r\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param first The date to at which the resulting observable will timeout if the source observable\r\n * does not emit at least one value.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\r\n * This is functionally the same as `timeout({ each: milliseconds })`.\r\n *\r\n * <span class=\"informal\">Errors if it waits too long between any value</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @param each The time allowed between each pushed value from the source before the resulting observable\r\n * will timeout.\r\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\r\n */\r\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n *\r\n * Errors if Observable does not emit a value in given time span.\r\n *\r\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\r\n *\r\n * ![](timeout.png)\r\n *\r\n * @see {@link timeoutWith}\r\n *\r\n * @return A function that returns an Observable that mirrors behaviour of the\r\n * source Observable, unless timeout happens when it throws an error.\r\n */\r\nexport function timeout<T, O extends ObservableInput<any>, M>(\r\n  config: number | Date | TimeoutConfig<T, O, M>,\r\n  schedulerArg?: SchedulerLike\r\n): OperatorFunction<T, T | ObservedValueOf<O>> {\r\n  // Intentionally terse code.\r\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\r\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\r\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\r\n  // we destructure that into what we're going to use, setting important defaults as we do.\r\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\r\n  // it will default to the `asyncScheduler`.\r\n  const {\r\n    first,\r\n    each,\r\n    with: _with = timeoutErrorFactory,\r\n    scheduler = schedulerArg ?? asyncScheduler,\r\n    meta = null!,\r\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\r\n\r\n  if (first == null && each == null) {\r\n    // Ensure timeout was provided at runtime.\r\n    throw new TypeError('No timeout provided.');\r\n  }\r\n\r\n  return operate((source, subscriber) => {\r\n    // This subscription encapsulates our subscription to the\r\n    // source for this operator. We're capturing it separately,\r\n    // because if there is a `with` observable to fail over to,\r\n    // we want to unsubscribe from our original subscription, and\r\n    // hand of the subscription to that one.\r\n    let originalSourceSubscription: Subscription;\r\n    // The subscription for our timeout timer. This changes\r\n    // every time we get a new value.\r\n    let timerSubscription: Subscription;\r\n    // A bit of state we pass to our with and error factories to\r\n    // tell what the last value we saw was.\r\n    let lastValue: T | null = null;\r\n    // A bit of state we pass to the with and error factories to\r\n    // tell how many values we have seen so far.\r\n    let seen = 0;\r\n    const startTimer = (delay: number) => {\r\n      timerSubscription = executeSchedule(\r\n        subscriber,\r\n        scheduler,\r\n        () => {\r\n          try {\r\n            originalSourceSubscription.unsubscribe();\r\n            innerFrom(\r\n              _with!({\r\n                meta,\r\n                lastValue,\r\n                seen,\r\n              })\r\n            ).subscribe(subscriber);\r\n          } catch (err) {\r\n            subscriber.error(err);\r\n          }\r\n        },\r\n        delay\r\n      );\r\n    };\r\n\r\n    originalSourceSubscription = source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          // clear the timer so we can emit and start another one.\r\n          timerSubscription?.unsubscribe();\r\n          seen++;\r\n          // Emit\r\n          subscriber.next((lastValue = value));\r\n          // null | undefined are both < 0. Thanks, JavaScript.\r\n          each! > 0 && startTimer(each!);\r\n        },\r\n        undefined,\r\n        undefined,\r\n        () => {\r\n          if (!timerSubscription?.closed) {\r\n            timerSubscription?.unsubscribe();\r\n          }\r\n          // Be sure not to hold the last value in memory after unsubscription\r\n          // it could be quite large.\r\n          lastValue = null;\r\n        }\r\n      )\r\n    );\r\n\r\n    // Intentionally terse code.\r\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\r\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\r\n    // If `first` was provided, and it's a number, then use it.\r\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\r\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\r\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\r\n  });\r\n}\r\n\r\n/**\r\n * The default function to use to emit an error when timeout occurs and a `with` function\r\n * is not specified.\r\n * @param info The information about the timeout to pass along to the error\r\n */\r\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\r\n  throw new TimeoutError(info);\r\n}\r\n", "import { OperatorFunction } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\r\n\r\n/**\r\n * Applies a given `project` function to each value emitted by the source\r\n * Observable, and emits the resulting values as an Observable.\r\n *\r\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\r\n * it passes each source value through a transformation function to get\r\n * corresponding output values.</span>\r\n *\r\n * ![](map.png)\r\n *\r\n * Similar to the well known `Array.prototype.map` function, this operator\r\n * applies a projection to each value and emits that projection in the output\r\n * Observable.\r\n *\r\n * ## Example\r\n *\r\n * Map every click to the `clientX` position of that click\r\n *\r\n * ```ts\r\n * import { fromEvent, map } from 'rxjs';\r\n *\r\n * const clicks = fromEvent<PointerEvent>(document, 'click');\r\n * const positions = clicks.pipe(map(ev => ev.clientX));\r\n *\r\n * positions.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link mapTo}\r\n * @see {@link pluck}\r\n *\r\n * @param project The function to apply to each `value` emitted by the source\r\n * Observable. The `index` parameter is the number `i` for the i-th emission\r\n * that has happened since the subscription, starting from the number `0`.\r\n * @param thisArg An optional argument to define what `this` is in the\r\n * `project` function.\r\n * @return A function that returns an Observable that emits the values from the\r\n * source Observable transformed by the given `project` function.\r\n */\r\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\r\n  return operate((source, subscriber) => {\r\n    // The index of the value from the source. Used with projection.\r\n    let index = 0;\r\n    // Subscribe to the source, all errors and completions are sent along\r\n    // to the consumer.\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value: T) => {\r\n        // Call the projection function with the appropriate this context,\r\n        // and send the resulting value to the consumer.\r\n        subscriber.next(project.call(thisArg, value, index++));\r\n      })\r\n    );\r\n  });\r\n}\r\n", "import { OperatorFunction } from \"../types\";\r\nimport { map } from \"../operators/map\";\r\n\r\nconst { isArray } = Array;\r\n\r\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\r\n    return isArray(args) ? fn(...args) : fn(args);\r\n}\r\n\r\n/**\r\n * Used in several -- mostly deprecated -- situations where we need to \r\n * apply a list of arguments or a single argument to a result selector.\r\n */\r\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\r\n    return map(args => callOrApply(fn, args))\r\n}", "const { isArray } = Array;\r\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\r\n\r\n/**\r\n * Used in functions where either a list of arguments, a single array of arguments, or a\r\n * dictionary of arguments can be returned. Returns an object with an `args` property with\r\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\r\n * property.\r\n */\r\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\r\n  if (args.length === 1) {\r\n    const first = args[0];\r\n    if (isArray(first)) {\r\n      return { args: first, keys: null };\r\n    }\r\n    if (isPOJO(first)) {\r\n      const keys = getKeys(first);\r\n      return {\r\n        args: keys.map((key) => first[key]),\r\n        keys,\r\n      };\r\n    }\r\n  }\r\n\r\n  return { args: args as T[], keys: null };\r\n}\r\n\r\nfunction isPOJO(obj: any): obj is object {\r\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\r\n}\r\n", "import { Observable } from '../Observable';\r\nimport { noop } from '../util/noop';\r\n\r\n/**\r\n * An Observable that emits no items to the Observer and never completes.\r\n *\r\n * ![](never.png)\r\n *\r\n * A simple Observable that emits neither values nor errors nor the completion\r\n * notification. It can be used for testing purposes or for composing with other\r\n * Observables. Please note that by never emitting a complete notification, this\r\n * Observable keeps the subscription from being disposed automatically.\r\n * Subscriptions need to be manually disposed.\r\n *\r\n * ##  Example\r\n *\r\n * Emit the number 7, then never emit anything else (not even complete)\r\n *\r\n * ```ts\r\n * import { NEVER, startWith } from 'rxjs';\r\n *\r\n * const info = () => console.log('Will not be called');\r\n *\r\n * const result = NEVER.pipe(startWith(7));\r\n * result.subscribe({\r\n *   next: x => console.log(x),\r\n *   error: info,\r\n *   complete: info\r\n * });\r\n * ```\r\n *\r\n * @see {@link Observable}\r\n * @see {@link EMPTY}\r\n * @see {@link of}\r\n * @see {@link throwError}\r\n */\r\nexport const NEVER = new Observable<never>(noop);\r\n\r\n/**\r\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\r\n */\r\nexport function never() {\r\n  return NEVER;\r\n}\r\n", "const { isArray } = Array;\r\n\r\n/**\r\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\r\n * as a single argument.\r\n */\r\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\r\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\r\n}\r\n", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\r\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\r\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\r\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\r\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\r\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Filter items emitted by the source Observable by only emitting those that\r\n * satisfy a specified predicate.\r\n *\r\n * <span class=\"informal\">Like\r\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\r\n * it only emits a value from the source if it passes a criterion function.</span>\r\n *\r\n * ![](filter.png)\r\n *\r\n * Similar to the well-known `Array.prototype.filter` method, this operator\r\n * takes values from the source Observable, passes them through a `predicate`\r\n * function and only emits those values that yielded `true`.\r\n *\r\n * ## Example\r\n *\r\n * Emit only click events whose target was a DIV element\r\n *\r\n * ```ts\r\n * import { fromEvent, filter } from 'rxjs';\r\n *\r\n * const div = document.createElement('div');\r\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\r\n * document.body.appendChild(div);\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\r\n * clicksOnDivs.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link distinct}\r\n * @see {@link distinctUntilChanged}\r\n * @see {@link distinctUntilKeyChanged}\r\n * @see {@link ignoreElements}\r\n * @see {@link partition}\r\n * @see {@link skip}\r\n *\r\n * @param predicate A function that\r\n * evaluates each value emitted by the source Observable. If it returns `true`,\r\n * the value is emitted, if `false` the value is not passed to the output\r\n * Observable. The `index` parameter is the number `i` for the i-th source\r\n * emission that has happened since the subscription, starting from the number\r\n * `0`.\r\n * @param thisArg An optional argument to determine the value of `this`\r\n * in the `predicate` function.\r\n * @return A function that returns an Observable that emits items from the\r\n * source Observable that satisfy the specified `predicate`.\r\n */\r\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    // An index passed to our predicate function on each call.\r\n    let index = 0;\r\n\r\n    // Subscribe to the source, all errors and completions are\r\n    // forwarded to the consumer.\r\n    source.subscribe(\r\n      // Call the predicate with the appropriate `this` context,\r\n      // if the predicate returns `true`, then send the value\r\n      // to the consumer.\r\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\r\n    );\r\n  });\r\n}\r\n", "import { asyncScheduler } from '../scheduler/async';\r\nimport { Subscription } from '../Subscription';\r\nimport { MonoTypeOperatorFunction, SchedulerAction, SchedulerLike } from '../types';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits a notification from the source Observable only after a particular time span\r\n * has passed without another source emission.\r\n *\r\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\r\n * recent notification from each burst of emissions.</span>\r\n *\r\n * ![](debounceTime.png)\r\n *\r\n * `debounceTime` delays notifications emitted by the source Observable, but drops\r\n * previous pending delayed emissions if a new notification arrives on the source\r\n * Observable. This operator keeps track of the most recent notification from the\r\n * source Observable, and emits that only when `dueTime` has passed\r\n * without any other notification appearing on the source Observable. If a new value\r\n * appears before `dueTime` silence occurs, the previous notification will be dropped\r\n * and will not be emitted and a new `dueTime` is scheduled.\r\n * If the completing event happens during `dueTime` the last cached notification\r\n * is emitted before the completion event is forwarded to the output observable.\r\n * If the error event happens during `dueTime` or after it only the error event is\r\n * forwarded to the output observable. The cache notification is not emitted in this case.\r\n *\r\n * This is a rate-limiting operator, because it is impossible for more than one\r\n * notification to be emitted in any time window of duration `dueTime`, but it is also\r\n * a delay-like operator since output emissions do not occur at the same time as\r\n * they did on the source Observable. Optionally takes a {@link SchedulerLike} for\r\n * managing timers.\r\n *\r\n * ## Example\r\n *\r\n * Emit the most recent click after a burst of clicks\r\n *\r\n * ```ts\r\n * import { fromEvent, debounceTime } from 'rxjs';\r\n *\r\n * const clicks = fromEvent(document, 'click');\r\n * const result = clicks.pipe(debounceTime(1000));\r\n * result.subscribe(x => console.log(x));\r\n * ```\r\n *\r\n * @see {@link audit}\r\n * @see {@link auditTime}\r\n * @see {@link debounce}\r\n * @see {@link sample}\r\n * @see {@link sampleTime}\r\n * @see {@link throttle}\r\n * @see {@link throttleTime}\r\n *\r\n * @param dueTime The timeout duration in milliseconds (or the time unit determined\r\n * internally by the optional `scheduler`) for the window of time required to wait\r\n * for emission silence before emitting the most recent source value.\r\n * @param scheduler The {@link SchedulerLike} to use for managing the timers that\r\n * handle the timeout for each value.\r\n * @return A function that returns an Observable that delays the emissions of\r\n * the source Observable by the specified `dueTime`, and may drop some values\r\n * if they occur too frequently.\r\n */\r\nexport function debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\r\n  return operate((source, subscriber) => {\r\n    let activeTask: Subscription | null = null;\r\n    let lastValue: T | null = null;\r\n    let lastTime: number | null = null;\r\n\r\n    const emit = () => {\r\n      if (activeTask) {\r\n        // We have a value! Free up memory first, then emit the value.\r\n        activeTask.unsubscribe();\r\n        activeTask = null;\r\n        const value = lastValue!;\r\n        lastValue = null;\r\n        subscriber.next(value);\r\n      }\r\n    };\r\n    function emitWhenIdle(this: SchedulerAction<unknown>) {\r\n      // This is called `dueTime` after the first value\r\n      // but we might have received new values during this window!\r\n\r\n      const targetTime = lastTime! + dueTime;\r\n      const now = scheduler.now();\r\n      if (now < targetTime) {\r\n        // On that case, re-schedule to the new target\r\n        activeTask = this.schedule(undefined, targetTime - now);\r\n        subscriber.add(activeTask);\r\n        return;\r\n      }\r\n\r\n      emit();\r\n    }\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(\r\n        subscriber,\r\n        (value: T) => {\r\n          lastValue = value;\r\n          lastTime = scheduler.now();\r\n\r\n          // Only set up a task if it's not already up\r\n          if (!activeTask) {\r\n            activeTask = scheduler.schedule(emitWhenIdle, dueTime);\r\n            subscriber.add(activeTask);\r\n          }\r\n        },\r\n        () => {\r\n          // Source completed.\r\n          // Emit any pending debounced values then complete\r\n          emit();\r\n          subscriber.complete();\r\n        },\r\n        // Pass all errors through to consumer.\r\n        undefined,\r\n        () => {\r\n          // Finalization.\r\n          lastValue = activeTask = null;\r\n        }\r\n      )\r\n    );\r\n  });\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { EMPTY } from '../observable/empty';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\n/**\r\n * Emits only the first `count` values emitted by the source Observable.\r\n *\r\n * <span class=\"informal\">Takes the first `count` values from the source, then\r\n * completes.</span>\r\n *\r\n * ![](take.png)\r\n *\r\n * `take` returns an Observable that emits only the first `count` values emitted\r\n * by the source Observable. If the source emits fewer than `count` values then\r\n * all of its values are emitted. After that, it completes, regardless if the\r\n * source completes.\r\n *\r\n * ## Example\r\n *\r\n * Take the first 5 seconds of an infinite 1-second interval Observable\r\n *\r\n * ```ts\r\n * import { interval, take } from 'rxjs';\r\n *\r\n * const intervalCount = interval(1000);\r\n * const takeFive = intervalCount.pipe(take(5));\r\n * takeFive.subscribe(x => console.log(x));\r\n *\r\n * // Logs:\r\n * // 0\r\n * // 1\r\n * // 2\r\n * // 3\r\n * // 4\r\n * ```\r\n *\r\n * @see {@link takeLast}\r\n * @see {@link takeUntil}\r\n * @see {@link takeWhile}\r\n * @see {@link skip}\r\n *\r\n * @param count The maximum number of `next` values to emit.\r\n * @return A function that returns an Observable that emits only the first\r\n * `count` values emitted by the source Observable, or all of the values from\r\n * the source if the source emits fewer than `count` values.\r\n */\r\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\r\n  return count <= 0\r\n    ? // If we are taking no values, that's empty.\r\n      () => EMPTY\r\n    : operate((source, subscriber) => {\r\n        let seen = 0;\r\n        source.subscribe(\r\n          createOperatorSubscriber(subscriber, (value) => {\r\n            // Increment the number of values we have seen,\r\n            // then check it against the allowed count to see\r\n            // if we are still letting values through.\r\n            if (++seen <= count) {\r\n              subscriber.next(value);\r\n              // If we have met or passed our allowed count,\r\n              // we need to complete. We have to do <= here,\r\n              // because re-entrant code will increment `seen` twice.\r\n              if (count <= seen) {\r\n                subscriber.complete();\r\n              }\r\n            }\r\n          })\r\n        );\r\n      });\r\n}\r\n", "import { MonoTypeOperatorFunction } from '../types';\r\nimport { identity } from '../util/identity';\r\nimport { operate } from '../util/lift';\r\nimport { createOperatorSubscriber } from './OperatorSubscriber';\r\n\r\nexport function distinctUntilChanged<T>(comparator?: (previous: T, current: T) => boolean): MonoTypeOperatorFunction<T>;\r\nexport function distinctUntilChanged<T, K>(\r\n  comparator: (previous: K, current: K) => boolean,\r\n  keySelector: (value: T) => K\r\n): MonoTypeOperatorFunction<T>;\r\n\r\n/**\r\n * Returns a result {@link Observable} that emits all values pushed by the source observable if they\r\n * are distinct in comparison to the last value the result observable emitted.\r\n *\r\n * When provided without parameters or with the first parameter (`{@link distinctUntilChanged#comparator comparator}`),\r\n * it behaves like this:\r\n *\r\n * 1. It will always emit the first value from the source.\r\n * 2. For all subsequent values pushed by the source, they will be compared to the previously emitted values\r\n *    using the provided `comparator` or an `===` equality check.\r\n * 3. If the value pushed by the source is determined to be unequal by this check, that value is emitted and\r\n *    becomes the new \"previously emitted value\" internally.\r\n *\r\n * When the second parameter (`{@link distinctUntilChanged#keySelector keySelector}`) is provided, the behavior\r\n * changes:\r\n *\r\n * 1. It will always emit the first value from the source.\r\n * 2. The `keySelector` will be run against all values, including the first value.\r\n * 3. For all values after the first, the selected key will be compared against the key selected from\r\n *    the previously emitted value using the `comparator`.\r\n * 4. If the keys are determined to be unequal by this check, the value (not the key), is emitted\r\n *    and the selected key from that value is saved for future comparisons against other keys.\r\n *\r\n * ## Examples\r\n *\r\n * A very basic example with no `{@link distinctUntilChanged#comparator comparator}`. Note that `1` is emitted more than once,\r\n * because it's distinct in comparison to the _previously emitted_ value,\r\n * not in comparison to _all other emitted values_.\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * of(1, 1, 1, 2, 2, 2, 1, 1, 3, 3)\r\n *   .pipe(distinctUntilChanged())\r\n *   .subscribe(console.log);\r\n * // Logs: 1, 2, 1, 3\r\n * ```\r\n *\r\n * With a `{@link distinctUntilChanged#comparator comparator}`, you can do custom comparisons. Let's say\r\n * you only want to emit a value when all of its components have\r\n * changed:\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * const totallyDifferentBuilds$ = of(\r\n *   { engineVersion: '1.1.0', transmissionVersion: '1.2.0' },\r\n *   { engineVersion: '1.1.0', transmissionVersion: '1.4.0' },\r\n *   { engineVersion: '1.3.0', transmissionVersion: '1.4.0' },\r\n *   { engineVersion: '1.3.0', transmissionVersion: '1.5.0' },\r\n *   { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\r\n * ).pipe(\r\n *   distinctUntilChanged((prev, curr) => {\r\n *     return (\r\n *       prev.engineVersion === curr.engineVersion ||\r\n *       prev.transmissionVersion === curr.transmissionVersion\r\n *     );\r\n *   })\r\n * );\r\n *\r\n * totallyDifferentBuilds$.subscribe(console.log);\r\n *\r\n * // Logs:\r\n * // { engineVersion: '1.1.0', transmissionVersion: '1.2.0' }\r\n * // { engineVersion: '1.3.0', transmissionVersion: '1.4.0' }\r\n * // { engineVersion: '2.0.0', transmissionVersion: '1.5.0' }\r\n * ```\r\n *\r\n * You can also provide a custom `{@link distinctUntilChanged#comparator comparator}` to check that emitted\r\n * changes are only in one direction. Let's say you only want to get\r\n * the next record temperature:\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * const temps$ = of(30, 31, 20, 34, 33, 29, 35, 20);\r\n *\r\n * const recordHighs$ = temps$.pipe(\r\n *   distinctUntilChanged((prevHigh, temp) => {\r\n *     // If the current temp is less than\r\n *     // or the same as the previous record,\r\n *     // the record hasn't changed.\r\n *     return temp <= prevHigh;\r\n *   })\r\n * );\r\n *\r\n * recordHighs$.subscribe(console.log);\r\n * // Logs: 30, 31, 34, 35\r\n * ```\r\n *\r\n * Selecting update events only when the `updatedBy` field shows\r\n * the account changed hands.\r\n *\r\n * ```ts\r\n * import { of, distinctUntilChanged } from 'rxjs';\r\n *\r\n * // A stream of updates to a given account\r\n * const accountUpdates$ = of(\r\n *   { updatedBy: 'blesh', data: [] },\r\n *   { updatedBy: 'blesh', data: [] },\r\n *   { updatedBy: 'ncjamieson', data: [] },\r\n *   { updatedBy: 'ncjamieson', data: [] },\r\n *   { updatedBy: 'blesh', data: [] }\r\n * );\r\n *\r\n * // We only want the events where it changed hands\r\n * const changedHands$ = accountUpdates$.pipe(\r\n *   distinctUntilChanged(undefined, update => update.updatedBy)\r\n * );\r\n *\r\n * changedHands$.subscribe(console.log);\r\n * // Logs:\r\n * // { updatedBy: 'blesh', data: Array[0] }\r\n * // { updatedBy: 'ncjamieson', data: Array[0] }\r\n * // { updatedBy: 'blesh', data: Array[0] }\r\n * ```\r\n *\r\n * @see {@link distinct}\r\n * @see {@link distinctUntilKeyChanged}\r\n *\r\n * @param comparator A function used to compare the previous and current keys for\r\n * equality. Defaults to a `===` check.\r\n * @param keySelector Used to select a key value to be passed to the `comparator`.\r\n *\r\n * @return A function that returns an Observable that emits items from the\r\n * source Observable with distinct values.\r\n */\r\nexport function distinctUntilChanged<T, K>(\r\n  comparator?: (previous: K, current: K) => boolean,\r\n  keySelector: (value: T) => K = identity as (value: T) => K\r\n): MonoTypeOperatorFunction<T> {\r\n  // We've been allowing `null` do be passed as the `compare`, so we can't do\r\n  // a default value for the parameter, because that will only work\r\n  // for `undefined`.\r\n  comparator = comparator ?? defaultCompare;\r\n\r\n  return operate((source, subscriber) => {\r\n    // The previous key, used to compare against keys selected\r\n    // from new arrivals to determine \"distinctiveness\".\r\n    let previousKey: K;\r\n    // Whether or not this is the first value we've gotten.\r\n    let first = true;\r\n\r\n    source.subscribe(\r\n      createOperatorSubscriber(subscriber, (value) => {\r\n        // We always call the key selector.\r\n        const currentKey = keySelector(value);\r\n\r\n        // If it's the first value, we always emit it.\r\n        // Otherwise, we compare this key to the previous key, and\r\n        // if the comparer returns false, we emit.\r\n        if (first || !comparator!(previousKey, currentKey)) {\r\n          // Update our state *before* we emit the value\r\n          // as emission can be the source of re-entrant code\r\n          // in functional libraries like this. We only really\r\n          // need to do this if it's the first value, or if the\r\n          // key we're tracking in previous needs to change.\r\n          first = false;\r\n          previousKey = currentKey;\r\n\r\n          // Emit the value!\r\n          subscriber.next(value);\r\n        }\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\nfunction defaultCompare(a: any, b: any) {\r\n  return a === b;\r\n}\r\n", "import { BehaviorSubject, isObservable, firstValueFrom, Subject, Observable, pipe, asapScheduler } from 'rxjs';\r\nimport { filter, take, map, distinctUntilChanged, debounceTime } from 'rxjs/operators';\r\n\r\nfunction createState(...propsFactories) {\r\n  const result = {\r\n    config: {},\r\n    state: {}\r\n  };\r\n  for (const {\r\n    config,\r\n    props\r\n  } of propsFactories) {\r\n    Object.assign(result.config, config);\r\n    Object.assign(result.state, props);\r\n  }\r\n  return result;\r\n}\r\n\r\nlet asyncBatchesInProgress = 0;\r\nconst batchInProgress = new BehaviorSubject(false);\r\nconst batchDone$ = batchInProgress.asObservable().pipe(filter(inProgress => !inProgress), take(1));\r\nfunction emitOnce(cb) {\r\n  if (!batchInProgress.getValue()) {\r\n    batchInProgress.next(true);\r\n    const value = cb();\r\n    if (asyncBatchesInProgress === 0) {\r\n      batchInProgress.next(false);\r\n    }\r\n    return value;\r\n  }\r\n  return cb();\r\n}\r\nasync function emitOnceAsync(cb) {\r\n  asyncBatchesInProgress++;\r\n  if (!batchInProgress.getValue()) {\r\n    batchInProgress.next(true);\r\n  }\r\n  const callbackReturnValue = cb();\r\n  const value = await (isObservable(callbackReturnValue) ? firstValueFrom(callbackReturnValue) : callbackReturnValue);\r\n  if (--asyncBatchesInProgress === 0) {\r\n    batchInProgress.next(false);\r\n  }\r\n  return value;\r\n}\r\n\r\n// this is internal object that's not exported to public API\r\nconst elfHooksRegistry = {};\r\nclass ElfHooks {\r\n  registerPreStoreUpdate(fn) {\r\n    elfHooksRegistry.preStoreUpdate = fn;\r\n  }\r\n  registerPreStateInit(fn) {\r\n    elfHooksRegistry.preStateInit = fn;\r\n  }\r\n}\r\nconst elfHooks = new ElfHooks();\r\n\r\nconst registry = new Map();\r\nconst registryActions = new Subject();\r\nconst registry$ = registryActions.asObservable();\r\n\r\n// @internal\r\nfunction addStore(store) {\r\n  registry.set(store.name, store);\r\n  registryActions.next({\r\n    type: 'add',\r\n    store\r\n  });\r\n}\r\n\r\n// @internal\r\nfunction removeStore(store) {\r\n  registry.delete(store.name);\r\n  registryActions.next({\r\n    type: 'remove',\r\n    store\r\n  });\r\n}\r\nfunction getStore(name) {\r\n  return registry.get(name);\r\n}\r\nfunction getRegistry() {\r\n  return registry;\r\n}\r\nfunction getStoresSnapshot() {\r\n  const stores = {};\r\n  registry.forEach((store, key) => {\r\n    stores[key] = store.getValue();\r\n  });\r\n  return stores;\r\n}\r\n\r\nlet events = [];\r\n\r\n/**\r\n *\r\n * @private function don't use\r\n *\r\n */\r\nfunction _setEvent(e) {\r\n  events.push(e);\r\n}\r\nfunction emitEvents(source) {\r\n  if (events.length) {\r\n    events.forEach(e => source.next(e));\r\n  }\r\n  events = [];\r\n}\r\n\r\nclass Store extends BehaviorSubject {\r\n  constructor(storeDef) {\r\n    super(storeDef.state);\r\n    this.storeDef = storeDef;\r\n    this.initialState = void 0;\r\n    this.state = void 0;\r\n    this.batchInProgress = false;\r\n    this.events = new Subject();\r\n    this.context = {\r\n      config: this.getConfig(),\r\n      setEvent: action => {\r\n        _setEvent(action);\r\n      }\r\n    };\r\n    this.events$ = this.events.asObservable();\r\n    this.state = this.getInitialState(storeDef.state);\r\n    this.initialState = this.getValue();\r\n    addStore(this);\r\n  }\r\n  get name() {\r\n    return this.storeDef.name;\r\n  }\r\n  getInitialState(state) {\r\n    if (elfHooksRegistry.preStateInit) {\r\n      return elfHooksRegistry.preStateInit(state, this.name);\r\n    }\r\n    return state;\r\n  }\r\n  getConfig() {\r\n    return this.storeDef.config;\r\n  }\r\n  query(selector) {\r\n    return selector(this.getValue());\r\n  }\r\n  update(...reducers) {\r\n    const currentState = this.getValue();\r\n    let nextState = reducers.reduce((value, reducer) => {\r\n      value = reducer(value, this.context);\r\n      return value;\r\n    }, currentState);\r\n    if (elfHooksRegistry.preStoreUpdate) {\r\n      nextState = elfHooksRegistry.preStoreUpdate(currentState, nextState, this.name);\r\n    }\r\n    if (nextState !== currentState) {\r\n      this.state = nextState;\r\n      if (batchInProgress.getValue()) {\r\n        if (!this.batchInProgress) {\r\n          this.batchInProgress = true;\r\n          batchDone$.subscribe(() => {\r\n            super.next(this.state);\r\n            emitEvents(this.events);\r\n            this.batchInProgress = false;\r\n          });\r\n        }\r\n      } else {\r\n        super.next(this.state);\r\n        emitEvents(this.events);\r\n      }\r\n    }\r\n  }\r\n  getValue() {\r\n    return this.state;\r\n  }\r\n  reset() {\r\n    this.update(() => this.initialState);\r\n  }\r\n  combine(observables) {\r\n    let hasChange = true;\r\n    const buffer = {};\r\n    return new Observable(observer => {\r\n      for (const [key, query] of Object.entries(observables)) {\r\n        observer.add(query.subscribe(value => {\r\n          buffer[key] = value;\r\n          hasChange = true;\r\n        }));\r\n      }\r\n      return this.subscribe({\r\n        next() {\r\n          if (hasChange) {\r\n            observer.next({\r\n              ...buffer\r\n            });\r\n            hasChange = false;\r\n          }\r\n        },\r\n        error(e) {\r\n          observer.error(e);\r\n        },\r\n        complete() {\r\n          observer.complete();\r\n        }\r\n      });\r\n    });\r\n  }\r\n  destroy() {\r\n    removeStore(this);\r\n    this.reset();\r\n  }\r\n  next(value) {\r\n    this.update(() => value);\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  error() {}\r\n\r\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n  complete() {}\r\n}\r\n\r\nfunction createStore(storeConfig, ...propsFactories) {\r\n  const {\r\n    state,\r\n    config\r\n  } = createState(...propsFactories);\r\n  const {\r\n    name\r\n  } = storeConfig;\r\n  return new Store({\r\n    name,\r\n    state,\r\n    config\r\n  });\r\n}\r\n\r\nfunction coerceArray(value) {\r\n  return Array.isArray(value) ? value : [value];\r\n}\r\nfunction isFunction(value) {\r\n  return typeof value === 'function';\r\n}\r\nfunction isUndefined(value) {\r\n  return value === undefined;\r\n}\r\nfunction isString(value) {\r\n  return typeof value === 'string';\r\n}\r\nfunction capitalize(key) {\r\n  return key.charAt(0).toUpperCase() + key.slice(1);\r\n}\r\nfunction isObject(item) {\r\n  return typeof item === 'object' && !Array.isArray(item) && item !== null;\r\n}\r\nfunction deepFreeze(o) {\r\n  Object.freeze(o);\r\n  const oIsFunction = typeof o === 'function';\r\n  const hasOwnProp = Object.prototype.hasOwnProperty;\r\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\r\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\r\n      deepFreeze(o[prop]);\r\n    }\r\n  });\r\n  return o;\r\n}\r\n\r\n/**\r\n *\r\n * Update a root property of the state\r\n *\r\n * @example\r\n *\r\n * store.update(setProp('foo', 'bar'))\r\n *\r\n * @example\r\n *\r\n * store.update(setProp('count', count => count + 1))\r\n *\r\n */\r\nfunction setProp(key, value) {\r\n  return function (state) {\r\n    return {\r\n      ...state,\r\n      [key]: isFunction(value) ? value(state[key]) : value\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n *\r\n * Update a root property of the state\r\n *\r\n * @example\r\n *\r\n * store.update(setProps({ count: 1, bar: 'baz'}))\r\n *\r\n * @example\r\n *\r\n * store.update(setProps(state => ({\r\n *   count: 1,\r\n *   nested: {\r\n *     ...state.nested,\r\n *     foo: 'bar'\r\n *   }\r\n * })))\r\n *\r\n */\r\nfunction setProps(props) {\r\n  return function (state) {\r\n    return {\r\n      ...state,\r\n      ...(isFunction(props) ? props(state) : props)\r\n    };\r\n  };\r\n}\r\n\r\nfunction select(mapFn) {\r\n  return pipe(map(mapFn), distinctUntilChanged());\r\n}\r\nfunction head() {\r\n  return map(arr => arr[0]);\r\n}\r\nfunction distinctUntilArrayItemChanged() {\r\n  return distinctUntilChanged((prevCollection, currentCollection) => {\r\n    if (prevCollection === currentCollection) {\r\n      return true;\r\n    }\r\n    if (prevCollection.length !== currentCollection.length) {\r\n      return false;\r\n    }\r\n    const isOneOfItemReferenceChanged = currentCollection.some((item, i) => {\r\n      return prevCollection[i] !== item;\r\n    });\r\n\r\n    // return false means there is a change and we want to call next()\r\n    return !isOneOfItemReferenceChanged;\r\n  });\r\n}\r\nconst asap = () => debounceTime(0, asapScheduler);\r\nfunction filterNil() {\r\n  return filter(value => value !== null && value !== undefined);\r\n}\r\n\r\nfunction propsFactory(key, {\r\n  initialValue: propsFactoryInitialValue,\r\n  config\r\n}) {\r\n  let initialValue = propsFactoryInitialValue;\r\n  const normalizedKey = capitalize(key);\r\n  return {\r\n    [`with${normalizedKey}`](value = initialValue) {\r\n      return {\r\n        props: {\r\n          [key]: value\r\n        },\r\n        config\r\n      };\r\n    },\r\n    [`set${normalizedKey}InitialValue`](value) {\r\n      initialValue = value;\r\n    },\r\n    [`set${normalizedKey}`](value) {\r\n      return function (state) {\r\n        const newVal = isFunction(value) ? value(state) : value;\r\n        if (newVal === state[key]) {\r\n          return state;\r\n        }\r\n        return {\r\n          ...state,\r\n          [key]: newVal\r\n        };\r\n      };\r\n    },\r\n    [`update${normalizedKey}`](value) {\r\n      return function (state) {\r\n        const newVal = isFunction(value) ? value(state) : value;\r\n        if (newVal === state[key]) {\r\n          return state;\r\n        }\r\n        return {\r\n          ...state,\r\n          [key]: isObject(newVal) ? {\r\n            ...state[key],\r\n            ...newVal\r\n          } : newVal\r\n        };\r\n      };\r\n    },\r\n    [`reset${normalizedKey}`]() {\r\n      return function (state) {\r\n        return {\r\n          ...state,\r\n          [key]: initialValue\r\n        };\r\n      };\r\n    },\r\n    [`select${normalizedKey}`]() {\r\n      return select(state => state[key]);\r\n    },\r\n    [`get${normalizedKey}`](state) {\r\n      return state[key];\r\n    }\r\n  };\r\n}\r\n\r\nfunction propsArrayFactory(key, options) {\r\n  const normalizedKey = capitalize(key);\r\n  const base = propsFactory(key, options);\r\n  return {\r\n    ...base,\r\n    [`add${normalizedKey}`](items) {\r\n      return function (state) {\r\n        return {\r\n          ...state,\r\n          [key]: arrayAdd(state[key], items)\r\n        };\r\n      };\r\n    },\r\n    [`remove${normalizedKey}`](items) {\r\n      return function (state) {\r\n        return {\r\n          ...state,\r\n          [key]: arrayRemove(state[key], items)\r\n        };\r\n      };\r\n    },\r\n    [`toggle${normalizedKey}`](items) {\r\n      return function (state) {\r\n        return {\r\n          ...state,\r\n          [key]: arrayToggle(state[key], items)\r\n        };\r\n      };\r\n    },\r\n    [`update${normalizedKey}`](predicateOrIds, obj) {\r\n      return function (state) {\r\n        return {\r\n          ...state,\r\n          [key]: arrayUpdate(state[key], predicateOrIds, obj)\r\n        };\r\n      };\r\n    },\r\n    [`in${normalizedKey}`](item) {\r\n      return state => inArray(state[key], item);\r\n    }\r\n  };\r\n}\r\nfunction arrayAdd(arr, items) {\r\n  return [...arr, ...coerceArray(items)];\r\n}\r\nfunction arrayRemove(arr, items) {\r\n  const toArray = coerceArray(items);\r\n  return arr.filter(current => !toArray.includes(current));\r\n}\r\nfunction arrayToggle(arr, items) {\r\n  const toArray = coerceArray(items);\r\n  const result = [...arr];\r\n  toArray.forEach(item => {\r\n    const i = result.indexOf(item);\r\n    i > -1 ? result.splice(i, 1) : result.push(item);\r\n  });\r\n  return result;\r\n}\r\nfunction inArray(arr, item) {\r\n  return arr.includes(item);\r\n}\r\nfunction arrayUpdate(arr, item, newItem) {\r\n  return arr.map(current => {\r\n    return current === item ? newItem : current;\r\n  });\r\n}\r\n\r\nfunction withProps(props) {\r\n  return {\r\n    props,\r\n    config: undefined\r\n  };\r\n}\r\n\r\nlet __DEV__ = true;\r\nfunction enableElfProdMode() {\r\n  __DEV__ = false;\r\n}\r\n\r\n// @internal\r\nfunction isDev() {\r\n  return __DEV__;\r\n}\r\n\r\nexport { Store, _setEvent, asap, capitalize, coerceArray, createState, createStore, deepFreeze, distinctUntilArrayItemChanged, elfHooks, emitOnce, emitOnceAsync, enableElfProdMode, filterNil, getRegistry, getStore, getStoresSnapshot, head, isDev, isFunction, isObject, isString, isUndefined, propsArrayFactory, propsFactory, registry$, select, setProp, setProps, withProps };\r\n"],
  "mappings": "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",
  "names": ["d", "b", "from", "v", "Subscription", "empty", "timeout", "Subscriber", "ConsumerObserver", "SafeSubscriber", "Observable", "observable", "OperatorSubscriber", "err", "ConnectableObservable", "timestamp", "timestamp", "Subject", "observable", "AnonymousSubject", "BehaviorSubject", "ReplaySubject", "last", "AsyncSubject", "Action", "delay", "timeout", "AsyncAction", "delay", "AsapAction", "delay", "Scheduler", "delay", "AsyncScheduler", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "delay", "repeat", "delay", "delay", "iterator", "iterator", "NotificationKind", "Notification", "config", "isArray", "isArray", "count", "first", "config", "buffer", "isFunction", "asap", "toArray"]
}
